[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "news\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nJul 12, 2022\n\n\nTaylor Dunn, Harlow Malloc\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nJul 9, 2022\n\n\nTaylor Dunn, Tristan O’Malley\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nR\n\n\nmachine learning\n\n\ntidymodels\n\n\nXGBoost\n\n\nGoogle Cloud Platform\n\n\nDocker\n\n\nShiny\n\n\nforecasting\n\n\nMLOps\n\n\n\n\nPart 3 of predicting bike ridership in Halifax, Nova Scotia. In this post, I deploy the machine learning model on Google Cloud Platform.\n\n\n\n\n\n\nMay 19, 2022\n\n\nTaylor Dunn\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nR\n\n\nmachine learning\n\n\ntidymodels\n\n\nrandom forest\n\n\nXGBoost\n\n\nsupport-vector machine\n\n\nforecasting\n\n\n\n\nPart 2 of predicting bike ridership in Halifax, Nova Scotia. In this post, I explore and tune different modeling approaches.\n\n\n\n\n\n\nApr 29, 2022\n\n\nTaylor Dunn\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nR\n\n\nAPI\n\n\n\n\nPart 1 of predicting bike ridership in Halifax, Nova Scotia. In this post, I retrieve and explore data from two open APIs.\n\n\n\n\n\n\nApr 27, 2022\n\n\nTaylor Dunn\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\n\n\nR\n\n\nregression\n\n\nordinal\n\n\nfrequentist statistics\n\n\n\n\nA theoretical and applied walkthrough of ordinal regression. Part 1: the frequentist approach with ordinal.\n\n\n\n\n\n\nMar 15, 2020\n\n\nTaylor Dunn\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2020-03-15-ordinal-regression-in-r-part-1/ordinal-regression-in-r-part-1.html",
    "href": "posts/2020-03-15-ordinal-regression-in-r-part-1/ordinal-regression-in-r-part-1.html",
    "title": "Ordinal regression in R: part 1",
    "section": "",
    "text": "R setup\nlibrary(tidyverse)\nlibrary(dunnr)\nlibrary(gt)\nlibrary(broom)\nlibrary(patchwork)\n\nextrafont::loadfonts(device = \"win\", quiet = TRUE)\ntheme_set(theme_td())\nset_geom_fonts()\nset_palette()\n\nwine_red <- \"#58181F\"\nupdate_geom_defaults(\"point\", list(color = wine_red))\nupdate_geom_defaults(\"line\", list(color = wine_red))\nThe purpose of this post is to learn more about ordinal regression models (a.k.a. cumulative link, proportional odds, ordered logit models, etc.) and practice their implementation in R. This is part 1, where I’ll be taking the frequentist approach via the ordinal package. There are other options, like MASS::polr, but two features in particular drew me to ordinal: (1) it allows for random effects, and (2) it has broom::tidy methods available.\nParticularly, I’ll be following along with"
  },
  {
    "objectID": "posts/2020-03-15-ordinal-regression-in-r-part-1/ordinal-regression-in-r-part-1.html#setup",
    "href": "posts/2020-03-15-ordinal-regression-in-r-part-1/ordinal-regression-in-r-part-1.html#setup",
    "title": "Ordinal regression in R: part 1",
    "section": "Setup",
    "text": "Setup\nImport ordinal, and the included data set wine:\n\nlibrary(ordinal)\ndata(wine)\nwine <- as_tibble(wine)\nglimpse(wine)\n\nRows: 72\nColumns: 6\n$ response <dbl> 36, 48, 47, 67, 77, 60, 83, 90, 17, 22, 14, 50, 30, 51, 90, 7…\n$ rating   <ord> 2, 3, 3, 4, 4, 4, 5, 5, 1, 2, 1, 3, 2, 3, 5, 4, 2, 3, 3, 2, 5…\n$ temp     <fct> cold, cold, cold, cold, warm, warm, warm, warm, cold, cold, c…\n$ contact  <fct> no, no, yes, yes, no, no, yes, yes, no, no, yes, yes, no, no,…\n$ bottle   <fct> 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5…\n$ judge    <fct> 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3…\n\n\nwine is a data set from Randall (1989) of wine bitterness ratings from multiple judges. The variables are as follows:\n\nOutcome:\n\nresponse: wine bitterness rating on a 0-100 scale\nrating: ordered factor with 5 levels (grouped version of response) with 1 = “least bitter” and 5 = “most bitter”\n\nTreatment factors:\n\ntemp: temperature during wine production (cold and warm)\ncontact: contact between juice and skins during wine production (no and yes)\n\nRandom effects\n\nbottle with 8 levels\njudge with 9 levels\n\n\nRelationship between response and rating:\n\nwine %>%\n  ggplot(aes(y = rating, x = response)) +\n  geom_boxplot(width = 0.5) +\n  geom_jitter(alpha = 0.5)\n\n\n\n\nNote that there is no overlap between the levels.\nThere are 72 total observations with the following ratings distribution by treatment and random effects:\n\nwine %>%\n  transmute(temp, contact, bottle, judge, rating = as.numeric(rating)) %>%\n  pivot_wider(names_from = judge, values_from = rating) %>%\n  gt() %>%\n  tab_spanner(columns = `1`:`9`, label = \"judge\") %>%\n  data_color(\n    columns = `1`:`9`,\n    colors = scales::col_numeric(\n      palette = c(\"white\", wine_red), domain = c(1, 5)\n    )\n  )\n\n\n\n\n\n  \n  \n    \n      temp\n      contact\n      bottle\n      \n        judge\n      \n    \n    \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n    \n  \n  \n    cold\nno\n1\n2\n1\n2\n3\n2\n3\n1\n2\n1\n    cold\nno\n2\n3\n2\n3\n2\n3\n2\n1\n2\n2\n    cold\nyes\n3\n3\n1\n3\n3\n4\n3\n2\n2\n3\n    cold\nyes\n4\n4\n3\n2\n2\n3\n2\n2\n3\n2\n    warm\nno\n5\n4\n2\n5\n3\n3\n2\n2\n3\n3\n    warm\nno\n6\n4\n3\n5\n2\n3\n4\n3\n3\n2\n    warm\nyes\n7\n5\n5\n4\n5\n3\n5\n2\n3\n4\n    warm\nyes\n8\n5\n4\n4\n3\n3\n4\n3\n4\n4\n  \n  \n  \n\n\n\n\nSo each bottle had a particular temp and contact (2 bottles for each of the 4 combinations), and each judge rated the bitterness each bottle.\nBefore modeling, can we see a clear effect of temp and contact?\n\nwine %>%\n  count(contact, rating, temp) %>%\n  mutate(temp = fct_rev(temp)) %>%\n  ggplot(aes(x = temp, y = rating, color = temp)) +\n  geom_point(aes(group = temp, size = n)) +\n  facet_wrap(~contact, scales = \"free_x\",\n             labeller = labeller(contact = label_both)) +\n  scale_size(breaks = c(1, 2, 4, 6, 8)) +\n  add_facet_borders()\n\n\n\n\nAt a glance, it looks like the temp = warm and contact = yes is associated with higher ratings."
  },
  {
    "objectID": "posts/2020-03-15-ordinal-regression-in-r-part-1/ordinal-regression-in-r-part-1.html#the-cumulative-link-model",
    "href": "posts/2020-03-15-ordinal-regression-in-r-part-1/ordinal-regression-in-r-part-1.html#the-cumulative-link-model",
    "title": "Ordinal regression in R: part 1",
    "section": "The cumulative link model",
    "text": "The cumulative link model\n\nTheory\nThe ordinal response \\(y_i\\) falls into response category \\(j\\) (out of \\(J\\) total) with probability \\(\\pi_{ij}\\). The cumulative probabilities are defined:\n\\[\nP(y_i \\leq j) = \\pi_{i1} + \\dots + \\pi_{ij}.\n\\]\nAs an oversimplification, suppose that each probability \\(\\pi_{ij}\\) is equal to the proportion of that response in the wine data. Then the cumulative “probability” can be visualized:\n\nwine_prop <- wine %>%\n  count(rating) %>%\n  mutate(p = n / sum(n), cumsum_p = cumsum(p))\n\n(\n  ggplot(wine_prop, aes(x = rating, y = p)) +\n    geom_col(fill = wine_red) +\n    scale_y_continuous(labels = scales::percent, expand = c(0, 0)) +\n    labs(x = \"j\", y = \"proportion\")\n) +\n  (\n    ggplot(wine_prop, aes(x = as.integer(rating), y = cumsum_p)) +\n      geom_point(size = 2) +\n      geom_line(size = 1) +\n      labs(x = \"j\", y = \"cumulative proportion\")\n  ) +\n  (\n    ggplot(wine_prop,\n        aes(x = as.integer(rating), y = log(cumsum_p) - log(1 - cumsum_p))) +\n      geom_point(size = 2) +\n      geom_line(size = 1) +\n      labs(x = \"j\", y = \"logit(cumulative proportion)\")\n  )\n\n\n\n\nWe will explore other links, but first the most common, the logit link, which is depicted in the right-most panel of the above figure:\n\\[\n\\text{logit} (P(y_i \\leq j) = \\log \\frac{P(y_i \\leq j)}{1 - P(y_i \\leq j)}\n\\]\nNote that the above function is defined for all but the last category \\(j = J\\), because \\(1 - P(Y_i \\leq J) = 1 - 1 = 0\\).\nFor the wine data, where we have \\(J\\) = 5 rating categories, we will build up to the following mixed effects model:\n\\[\n\\begin{align}\n\\text{logit}(p(y_i \\leq j)) &= \\theta_j - \\beta_1 \\text{temp}_i - \\beta_2 \\text{contact}_i - u( \\text{judge}_i) \\\\\ni &= 1, \\dots n \\; \\; \\; \\; \\; \\; j = 1, \\dots, J - 1\n\\end{align}\n\\]\nwhere \\(\\theta_j\\) is called the threshold parameter, or cutpoint, of category \\(j\\). These thresholds can also be thought of as \\(J-1\\) = 4 intercepts. Note that the fixed effect parameters \\(\\beta_1\\) and \\(\\beta_2\\) are independent of \\(j\\), so each \\(\\beta\\) has the same effect for each of the \\(J-1\\) cumulative logits. The judge effects, which are also independent of \\(j\\), are assumed normal: \\(u(\\text{judge}_i) \\sim N(0, \\sigma_u^2)\\). We are using the logit link because it is the most popular for this kind of model (and the one I am familiar with), but there are other options we will briefly explore later.\nThe subtraction of terms in the above model is new to me. The main reason seems to be for familiar interpretation: the larger the value of any independent term \\(\\beta x\\), the smaller the thresholds \\(\\theta_j\\), and therefore a larger probability of the a response falling into a category at the upper end of the scale. This way, \\(\\beta\\) has the same direction of effect as in ordinary linear regression.\nWe are essentially modeling a “chain” of logistic regressions where the binary response is “less than or equal to a certain level” vs “greater than that level”. In this case, with \\(J\\) = 5, the thresholds \\(\\theta_j\\) are capturing the adjusted log-odds of observing:\n\n\\(j\\) = 1: log-odds of rating = 1 vs. 2-5\n\\(j\\) = 2: log-odds of rating = 1-2 vs. 3-5\n\\(j\\) = 3: log-odds of rating = 1-3 vs. 4-5\n\\(j\\) = 4: log-odds of rating = 1-4 vs. 5\n\n\n\nFitting\nNow with a surface-level understanding of what is being modeled, we will fit the data using ordinal::clm (cumulative link models) and ordinal::clmm (cumulative link mixed models), and logit links.\n\nFixed effects model\nFirst, fit a simple model, by maximum likelihood, with contact as the sole predictor:\n\\[\n\\text{logit}(p(y_i \\leq j)) = \\theta_j - \\beta_2 \\text{contact}_i\n\\]\n\nclm_rating_contact <-\n  clm(\n    rating ~ contact,\n    data = wine, link = \"logit\"\n  )\nsummary(clm_rating_contact)\n\nformula: rating ~ contact\ndata:    wine\n\n link  threshold nobs logLik AIC    niter max.grad cond.H \n logit flexible  72   -99.96 209.91 5(0)  1.67e-07 1.7e+01\n\nCoefficients:\n           Estimate Std. Error z value Pr(>|z|)   \ncontactyes   1.2070     0.4499   2.683   0.0073 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nThreshold coefficients:\n    Estimate Std. Error z value\n1|2 -2.13933    0.48981  -4.368\n2|3  0.04257    0.32063   0.133\n3|4  1.71449    0.38637   4.437\n4|5  2.97875    0.50207   5.933\n\n\nThe model gives us \\(K - 1 = 4\\) threshold coefficients, as expected. The \\(\\beta_2\\) coefficient estimate was statistically significant (by a Wald test), and tells us that contact = yes decreases the thresholds \\(\\theta_j\\) by \\(\\beta_2\\) = 1.21 (because of the subtraction of model terms), and therefore is associated with higher ratings.\nThe condition number of the Hessian for this model is 16.98. The ordinal primer says that larger values (like > 1e4) might indicate that the model is ill-defined.\nIt is nicely illustrative to compare this model to 4 separate logistic regressions with a dichotomized response:\n\\[\n\\begin{align}\n\\text{logit} (p(y_i \\leq 1)) &= \\theta_1 + \\beta_2 \\text{contact}_i \\\\\n\\text{logit} (p(y_i \\leq 2)) &= \\theta_2 + \\beta_2 \\text{contact}_i \\\\\n\\text{logit} (p(y_i \\leq 3)) &= \\theta_3 + \\beta_2 \\text{contact}_i \\\\\n\\text{logit} (p(y_i \\leq 4)) &= \\theta_4 + \\beta_2 \\text{contact}_i\n\\end{align}\n\\]\n\nwine %>%\n  crossing(j = 1:4) %>%\n  # Create a binary (0 or 1) to indicate where rating <= j\n  mutate(rating_leq_j = as.numeric(rating) <= j) %>%\n  group_by(j) %>%\n  nest() %>%\n  ungroup() %>%\n  mutate(\n    mod = map(\n      data,\n      ~glm(rating_leq_j ~ 1 + contact,\n           data = ., family = binomial(link = \"logit\")) %>% broom::tidy()\n    )\n  ) %>%\n  unnest(mod) %>%\n  transmute(\n    j, term,\n    estimate_se = str_c(round(estimate, 2), \" (\", round(std.error, 2), \")\")\n  ) %>%\n  pivot_wider(names_from = term, values_from = estimate_se) %>%\n  left_join(\n    tidy(clm_rating_contact) %>%\n      transmute(\n        j = as.integer(substr(term, 1, 1)),\n        term = if_else(!is.na(j), \"theta_j\", term),\n        estimate_se = str_c(round(estimate, 2), \" (\", round(std.error, 2), \")\")\n      ) %>%\n      mutate(j = replace_na(j, 1)) %>%\n      spread(term, estimate_se),\n    by = \"j\"\n  ) %>%\n  ungroup() %>%\n  gt() %>%\n  tab_spanner(label = \"Logistic regression\",\n              columns = c(`(Intercept)`, contactyes.x)) %>%\n  tab_spanner(label = \"CLM\",\n              columns = c(theta_j, contactyes.y)) %>%\n  fmt_missing(columns = everything(), missing_text = \"\")\n\n\n\n\n\n  \n  \n    \n      j\n      \n        Logistic regression\n      \n      \n        CLM\n      \n    \n    \n      (Intercept)\n      contactyes.x\n      theta_j\n      contactyes.y\n    \n  \n  \n    1\n-2.08 (0.53)\n-1.48 (1.14)\n-2.14 (0.49)\n1.21 (0.45)\n    2\n0 (0.33)\n-1.1 (0.51)\n0.04 (0.32)\n\n    3\n1.82 (0.48)\n-1.37 (0.59)\n1.71 (0.39)\n\n    4\n2.83 (0.73)\n-1.01 (0.87)\n2.98 (0.5)\n\n  \n  \n  \n\n\n\n\nThe intercepts from the ordinary logistic regression correspond closely to the threshold parameters \\(\\theta_j\\) from the cumulative link model. In the fixed effect of contact (\\(\\beta_2\\)), first note the sign difference, and second notice that the estimate from CLM is about the average of the 4 estimates from logistic regression. The advantage of the CLM is seen in the small standard error in the \\(\\beta_2\\) estimate.\nTo quote the primer:\n\nThe cumulative logit model can be seen as the model that combines these four ordinary logistic regression models into a single model and therefore makes better use of the information in the data.\n\nFor the second model, we add the \\(\\beta_1 \\text{temp}_i\\) term:\n\\[\n\\text{logit}(p(y_i \\leq j)) = \\theta_j - \\beta_1 \\text{temp}_i - \\beta_2 \\text{contact}_i\n\\]\n\nclm_rating_contact_temp <-\n  clm(\n    rating ~ contact + temp,\n    data = wine, link = \"logit\"\n  )\nsummary(clm_rating_contact_temp)\n\nformula: rating ~ contact + temp\ndata:    wine\n\n link  threshold nobs logLik AIC    niter max.grad cond.H \n logit flexible  72   -86.49 184.98 6(0)  4.01e-12 2.7e+01\n\nCoefficients:\n           Estimate Std. Error z value Pr(>|z|)    \ncontactyes   1.5278     0.4766   3.205  0.00135 ** \ntempwarm     2.5031     0.5287   4.735 2.19e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nThreshold coefficients:\n    Estimate Std. Error z value\n1|2  -1.3444     0.5171  -2.600\n2|3   1.2508     0.4379   2.857\n3|4   3.4669     0.5978   5.800\n4|5   5.0064     0.7309   6.850\n\n\nBoth fixed effects (contact = yes and temp = warm) are strongly associated with higher probability of higher ratings. The summary function provides \\(p\\)-values from Wald tests, but more accurate likelihood ratio tests can be done via the drop1 function, which evaluates each fixed effect while controlling the other:\n\ndrop1(clm_rating_contact_temp, test = \"Chisq\")\n\nSingle term deletions\n\nModel:\nrating ~ contact + temp\n        Df    AIC    LRT  Pr(>Chi)    \n<none>     184.98                     \ncontact  1 194.03 11.043 0.0008902 ***\ntemp     1 209.91 26.928 2.112e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nOr the reverse via the add1() function, which evaluates each fixed effect while ignoring the other:\n\n# Fit the null model first\nclm_rating_null <- clm(rating ~ 1, data = wine, link = \"logit\")\nadd1(clm_rating_null, scope = ~ contact + temp, test = \"Chisq\")\n\nSingle term additions\n\nModel:\nrating ~ 1\n        Df    AIC     LRT  Pr(>Chi)    \n<none>     215.44                      \ncontact  1 209.91  7.5263   0.00608 ** \ntemp     1 194.03 23.4113 1.308e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nSymmetric Wald confidence intervals can be extracted with confint or with broom::tidy:\n\ntidy(clm_rating_contact_temp, conf.int = TRUE, conf.type = \"Wald\") %>%\n  ggplot(aes(y = term, x = estimate)) +\n  geom_point(size = 2) +\n  geom_linerange(size = 1, aes(xmin = conf.low, xmax = conf.high))\n\n\n\n\nIn these types of analyses, we are often interested in the odds ratios. For the two categorical fixed effects, which have two levels each, the odds ratios \\(y \\leq j\\) comparing the two levels are:\n\\[\n\\begin{align}\n\\text{OR} &= \\frac{\\gamma_j (\\text{temp} = \\text{warm})}{\\gamma_j (\\text{temp} = \\text{cold})} = \\frac{\\exp(\\theta_j - \\beta_1 - \\beta_2 \\text{contact})}{\\exp (\\theta_j - 0 - \\beta_2 \\text{contact}}) = \\exp(\\beta_1) \\\\\n\\text{OR} &= \\frac{\\gamma_j (\\text{contact} = \\text{yes})}{\\gamma_j (\\text{contact} = \\text{no})} = \\frac{\\exp(\\theta_j - \\beta_1 \\text{temp} - \\beta_2 )}{\\exp (\\theta_j - \\beta_1 \\text{temp} - 0)}) = \\exp(\\beta_2)\n\\end{align}\n\\]\nwhere we have introduced the shorthand \\(\\gamma_j = \\text{logit} (p(y \\leq j))\\). Compute those odds ratios, and their corresponding Wald 95% CIs:\n\ntidy(clm_rating_contact_temp, conf.int = T, conf.type = \"Wald\") %>%\n  transmute(\n    term, across(c(estimate, conf.low, conf.high), exp)\n  ) %>%\n  gt() %>%\n  fmt_number(c(estimate, conf.low, conf.high), decimals = 2)\n\n\n\n\n\n  \n  \n    \n      term\n      estimate\n      conf.low\n      conf.high\n    \n  \n  \n    1|2\n0.26\n0.09\n0.72\n    2|3\n3.49\n1.48\n8.24\n    3|4\n32.04\n9.93\n103.39\n    4|5\n149.37\n35.65\n625.75\n    contactyes\n4.61\n1.81\n11.73\n    tempwarm\n12.22\n4.34\n34.44\n  \n  \n  \n\n\n\n\nOne last thing to check: does the data support an interaction between \\(\\text{temp}_i\\) and \\(\\text{contact}_i\\)?\n\\[\n\\text{logit}(p(y_i \\leq j)) = \\theta_j - \\beta_1 \\text{temp}_i - \\beta_2 \\text{contact}_i - \\beta_3 \\text{temp}_i \\text{contact}_i\n\\]\n\nclm_rating_contact_temp_inter <-\n  clm(\n    rating ~ contact * temp, data = wine, link = \"logit\"\n  )\n\n#drop1(clm_rating_contact_temp_inter, test = \"Chisq\") # this accomplishes the same thing as anova()\nanova(clm_rating_contact_temp, clm_rating_contact_temp_inter)\n\nLikelihood ratio tests of cumulative link models:\n \n                              formula:                link: threshold:\nclm_rating_contact_temp       rating ~ contact + temp logit flexible  \nclm_rating_contact_temp_inter rating ~ contact * temp logit flexible  \n\n                              no.par    AIC  logLik LR.stat df Pr(>Chisq)\nclm_rating_contact_temp            6 184.98 -86.492                      \nclm_rating_contact_temp_inter      7 186.83 -86.416  0.1514  1     0.6972\n\n\nNo, The interaction term contact:temp is not supported by the data.\n\nComparison to linear model\nConsider the following linear model which treats rating as continuous:\n\\[\ny_i = \\alpha + \\beta_1 \\text{temp}_i + \\beta_2 \\text{contact}_i + \\epsilon_i\n\\]\nwhere \\(\\epsilon_i \\sim N(0, \\sigma_{\\epsilon}^2)\\).\n\nlm_rating_contact_temp <- lm(as.numeric(rating) ~ contact + temp, data = wine)\n\nTo compare this to a CLM, we must use the probit link:\n\nclm_rating_contact_temp_probit <-\n  clm(\n    rating ~ contact + temp, data = wine, link = \"probit\"\n  )\ntidy(clm_rating_contact_temp_probit) %>%\n  filter(coef.type == \"location\") %>%\n  mutate(model = \"CLM\") %>%\n  select(-coef.type) %>%\n  bind_rows(\n    tidy(lm_rating_contact_temp) %>%\n      filter(term != \"(Intercept)\") %>%\n      # Need to divide by the residual SE here to get the right scale\n      mutate(estimate = estimate / summary(lm_rating_contact_temp)$sigma,\n             model = \"LM\")\n  ) %>%\n  group_by(model) %>%\n  gt() %>%\n  fmt_number(c(estimate, std.error, statistic), decimals = 2) %>%\n  fmt(p.value, fns = scales::pvalue)\n\n\n\n\n\n  \n  \n    \n      term\n      estimate\n      std.error\n      statistic\n      p.value\n    \n  \n  \n    \n      CLM\n    \n    contactyes\n0.87\n0.27\n3.25\n0.001\n    tempwarm\n1.50\n0.29\n5.14\n<0.001\n    \n      LM\n    \n    contactyes\n0.79\n0.20\n3.36\n0.001\n    tempwarm\n1.38\n0.20\n5.87\n<0.001\n  \n  \n  \n\n\n\n\nThe relative estimates from the linear model are lower than those from the CLM (probit link), indicating that the assumptions of the linear model are not met. In particular, the distance between thresholds is not equidistant, as we can see from differences in the CLM coefficients:\n\ndiff(coef(clm_rating_contact_temp_probit)[1:4]) %>% round(2)\n\n 2|3  3|4  4|5 \n1.51 1.31 0.90 \n\n\n\n\n\nMixed effects model\nNow that we have explored ordinal regression with just fixed effects, we will fit the following random effects model:\n\\[\n\\begin{align}\n\\text{logit}(p(y_i \\leq j)) &= \\theta_j - \\beta_1 \\text{temp}_i - \\beta_2 \\text{contact}_i - u( \\text{judge}_i) \\\\\ni &= 1, \\dots n \\; \\; \\; \\; \\; \\; j = 1, \\dots, J - 1\n\\end{align}\n\\]\nwhere the judge effects are independent of \\(j\\), and assumed normal: \\(u(\\text{judge}_i) \\sim N(0, \\sigma_u^2)\\).\nEach judge has 8 ratings each (two per combination of temp and contact). See if we can spot the judge variance in a plot of ratings:\n\nwine %>%\n  count(judge, rating) %>%\n  ggplot(aes(x = judge, y = rating)) +\n  geom_tile(aes(fill = n)) +\n  geom_text(aes(label = n), color = \"white\") +\n  scale_x_discrete(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) +\n  theme(legend.position = \"none\") +\n  labs(title = \"Number of ratings by judge\")\n\n\n\n\nThere is definitely some judge-specific variability in the perception of bitterness of wine. judge 5, for instance, doesn’t stray far from rating = 3, while judge 7 didn’t consider any of the wines particularly bitter.\nFit the full model with ordinal::clmm and logit link:\n\nclmm_rating_contact_temp <-\n  clmm(\n    rating ~ temp + contact + (1|judge),\n    data = wine, link = \"logit\"\n  )\n# This is an older function, which we need to run stats::profile later\nclmm2_rating_contact_temp <-\n  clmm2(\n    rating ~ temp + contact, random = judge,\n    data = wine, link = \"logistic\"\n  )\nsummary(clmm_rating_contact_temp)\n\nCumulative Link Mixed Model fitted with the Laplace approximation\n\nformula: rating ~ temp + contact + (1 | judge)\ndata:    wine\n\n link  threshold nobs logLik AIC    niter    max.grad cond.H \n logit flexible  72   -81.57 177.13 332(999) 1.03e-05 2.8e+01\n\nRandom effects:\n Groups Name        Variance Std.Dev.\n judge  (Intercept) 1.279    1.131   \nNumber of groups:  judge 9 \n\nCoefficients:\n           Estimate Std. Error z value Pr(>|z|)    \ntempwarm     3.0630     0.5954   5.145 2.68e-07 ***\ncontactyes   1.8349     0.5125   3.580 0.000344 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nThreshold coefficients:\n    Estimate Std. Error z value\n1|2  -1.6237     0.6824  -2.379\n2|3   1.5134     0.6038   2.507\n3|4   4.2285     0.8090   5.227\n4|5   6.0888     0.9725   6.261\n\n\nCompare model coefficients:\n\nbind_rows(\n  CLM = tidy(clm_rating_contact_temp),\n  CLMM = tidy(clmm_rating_contact_temp),\n  .id = \"model\"\n) %>%\n  select(-coef.type) %>%\n  group_by(model) %>%\n  gt() %>%\n  fmt_number(c(estimate, std.error, statistic), decimals = 2) %>%\n  fmt(p.value, fns = scales::pvalue)\n\n\n\n\n\n  \n  \n    \n      term\n      estimate\n      std.error\n      statistic\n      p.value\n    \n  \n  \n    \n      CLM\n    \n    1|2\n−1.34\n0.52\n−2.60\n0.009\n    2|3\n1.25\n0.44\n2.86\n0.004\n    3|4\n3.47\n0.60\n5.80\n<0.001\n    4|5\n5.01\n0.73\n6.85\n<0.001\n    contactyes\n1.53\n0.48\n3.21\n0.001\n    tempwarm\n2.50\n0.53\n4.73\n<0.001\n    \n      CLMM\n    \n    1|2\n−1.62\n0.68\n−2.38\n0.017\n    2|3\n1.51\n0.60\n2.51\n0.012\n    3|4\n4.23\n0.81\n5.23\n<0.001\n    4|5\n6.09\n0.97\n6.26\n<0.001\n    tempwarm\n3.06\n0.60\n5.14\n<0.001\n    contactyes\n1.83\n0.51\n3.58\n<0.001\n  \n  \n  \n\n\n\n\nBoth fixed effect estimates \\(\\beta_1\\) and \\(\\beta_2\\) are higher in the CLMM. Use anova to compare the CLMM to the CLM:\n\nanova(clm_rating_contact_temp, clmm_rating_contact_temp)\n\nLikelihood ratio tests of cumulative link models:\n \n                         formula:                              link: threshold:\nclm_rating_contact_temp  rating ~ contact + temp               logit flexible  \nclmm_rating_contact_temp rating ~ temp + contact + (1 | judge) logit flexible  \n\n                         no.par    AIC  logLik LR.stat df Pr(>Chisq)   \nclm_rating_contact_temp       6 184.98 -86.492                         \nclmm_rating_contact_temp      7 177.13 -81.565   9.853  1   0.001696 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\nUnsurprisingly, the judge term makes a significant improvement to the fit. We can extract profile confidence intervals on the variance \\(\\sigma_u\\) using stats::profile:\n\nprofile(clmm2_rating_contact_temp,\n        range = c(0.1, 4), nSteps = 30, trace = 0) %>%\n  confint()\n\n          2.5 %  97.5 %\nstDev 0.5014584 2.26678\n\n\nNote that these intervals are asymmetric (\\(\\sigma_u\\) = 1.28), unlike the less accurate Wald tests. We can produce “best guess” estimates for judge effects using conditional modes:\n\ntibble(\n  judge_effect = clmm_rating_contact_temp$ranef,\n  cond_var = clmm_rating_contact_temp$condVar\n) %>%\n  mutate(\n    judge = fct_reorder(factor(1:n()), judge_effect),\n    conf.low = judge_effect - qnorm(0.975) * sqrt(cond_var),\n    conf.high = judge_effect + qnorm(0.975) * sqrt(cond_var)\n  ) %>%\n  ggplot(aes(y = judge, x = judge_effect)) +\n  geom_point(size = 2) +\n  geom_linerange(size = 1, aes(xmin = conf.low, xmax = conf.high)) +\n  theme(panel.grid.major.x = element_line(color = \"grey\"))\n\n\n\n\n\nPredictions\nThere are different ways to extract predicted probabilities. First, and most obviously, with the predict function:\n\nwine %>%\n  bind_cols(\n    pred =  predict(\n      # Have to use clmm2 for predict\n      clmm2_rating_contact_temp, newdata = wine\n    )\n  ) %>%\n  # These are predicted probabilities for the average judge, so we can\n  #  exclude the judge variable\n  distinct(rating, temp, contact, pred) %>%\n  arrange(temp, contact, rating)\n\n# A tibble: 15 × 4\n   rating temp  contact   pred\n   <ord>  <fct> <fct>    <dbl>\n 1 1      cold  no      0.165 \n 2 2      cold  no      0.655 \n 3 3      cold  no      0.166 \n 4 1      cold  yes     0.0305\n 5 2      cold  yes     0.390 \n 6 3      cold  yes     0.496 \n 7 4      cold  yes     0.0696\n 8 2      warm  no      0.166 \n 9 3      warm  no      0.587 \n10 4      warm  no      0.191 \n11 5      warm  no      0.0463\n12 2      warm  yes     0.0313\n13 3      warm  yes     0.306 \n14 4      warm  yes     0.428 \n15 5      warm  yes     0.233 \n\n\nThis only gives us predictions for rating, temp and contact values which exist in the data. There is no predicted probability for rating > 3, temp cold and contact no, for example.\nAnother way is to pre-specify which values we want to predict:\n\nnd <-\n  crossing(\n    temp = factor(c(\"cold\", \"warm\")),\n    contact = factor(c(\"no\", \"yes\")),\n    rating = factor(1:5, ordered = T)\n  )\nnd %>%\n  bind_cols(pred = predict(clmm2_rating_contact_temp, nd)) %>%\n  ggplot(aes(x = glue::glue(\"{temp}-{contact}\"), y = pred, fill = rating)) +\n  geom_col() +\n  scale_fill_td(palette = \"div5\") +\n  scale_y_continuous(expand = c(0, 0), labels = scales::percent) +\n  labs(x = \"temp-contact\", y = \"predicted probability\")\n\n\n\n\nWe can also get model-estimated cumulative probabilities by considering the model coefficients. For example, for a cold temp and contact, the cumulative probability of a bitterness rating \\(j\\) or less:\n\\[\nP(y_i \\leq j) = \\text{logit}^{-1} [\\theta_j - \\beta_2 \\text{contact}_i]\n\\]\nwhere we are considering the average judge (\\(u(\\text{judge}_i) = 0\\)). The inverse logit is \\(\\text{logit}^{-1}(x) = 1 / (1 + \\exp(-x))\\), and can be calculated with plogis as a shorthand (brms::inv_logit_scaled is another). We can subtract cumulative probabilities to get non-cumulative probabilities of a rating \\(j\\). For example, \\(j\\) = 3:\n\nplogis(clmm_rating_contact_temp$Theta[3] - clmm_rating_contact_temp$beta[2]) -\n  plogis(clmm_rating_contact_temp$Theta[2] - clmm_rating_contact_temp$beta[2])\n\ncontactyes \n 0.4960357 \n\n\nwhich matches the value calculated previously using predict.\n\n\nEstimated marginal means\nThe emmeans package provides functionality for estimating marginal mean effects of ordinal models. The package documentation also provides an example using ordinal and wine data here.\n\nlibrary(emmeans)\n\nIn the “Models supported by emmeans” document, we see the following:\n\n\n\n\n\n\n\n\n\n\nObject.class\nPackage\nGroup\nArguments/notes\n\n\n\n\n\nclm\nordinal\nO\nmode = c(\"latent\", \"linear.predictor\", \"cum.prob\", \"exc.prob\", \"prob\", \"mean.class\", \"scale\")\n\n\n\nclmm\nordinal\nO\nLike clm but no \"scale\" mode\n\n\n\n\n\n\n\n\n\n\n\n\nemmeans(clmm_rating_contact_temp,\n        specs = list(pairwise ~ temp, pairwise ~ contact), mode = \"latent\")\n\n$`emmeans of temp`\n temp emmean    SE  df asymp.LCL asymp.UCL\n cold  -1.63 0.547 Inf    -2.707    -0.562\n warm   1.43 0.532 Inf     0.387     2.470\n\nResults are averaged over the levels of: contact \nConfidence level used: 0.95 \n\n$`pairwise differences of temp`\n 1           estimate    SE  df z.ratio p.value\n cold - warm    -3.06 0.595 Inf  -5.145  <.0001\n\nResults are averaged over the levels of: contact \n\n$`emmeans of contact`\n contact emmean    SE  df asymp.LCL asymp.UCL\n no      -1.020 0.522 Inf    -2.043   0.00274\n yes      0.815 0.513 Inf    -0.191   1.82072\n\nResults are averaged over the levels of: temp \nConfidence level used: 0.95 \n\n$`pairwise differences of contact`\n 1        estimate    SE  df z.ratio p.value\n no - yes    -1.83 0.513 Inf  -3.580  0.0003\n\nResults are averaged over the levels of: temp \n\n\nThe contrast estimates are in terms of the latent (underlying unobserved) bitterness rating.\nUsing mode = \"cum.prob\" and mode = \"exc.prob“, we can get cumulative probabilities and exceedance (1 - cumulative) probabilities. For example, the probability of a rating of at least 4 for different temp:\n\nemmeans(clmm_rating_contact_temp, ~ temp,\n        mode = \"exc.prob\", at = list(cut = \"3|4\"))\n\n temp exc.prob     SE  df asymp.LCL asymp.UCL\n cold    0.049 0.0304 Inf   -0.0107     0.109\n warm    0.450 0.1084 Inf    0.2371     0.662\n\nResults are averaged over the levels of: contact \nConfidence level used: 0.95 \n\n\nmode = \"prob\" gives us probability distributions of each rating, which have a nice auto plot functionality:\n\nemmeans(clmm_rating_contact_temp,\n        ~ rating | temp, mode = \"prob\") %>%\n  plot() +\n  add_facet_borders()\n\n\n\n\n\n\nChoice of link function\nSo far, we have used the logit link (and briefly the probit link to compare estimates with linear regression). The links available to ordinal::clmm are logit, probit, cloglog, loglog, and cauchit.\nWe can fit the CLMM using all of these links and compare log-likelihoods:\n\nwine %>%\n  nest(data = everything()) %>%\n  crossing(\n    link = c(\"logit\", \"probit\", \"cloglog\", \"loglog\", \"cauchit\")\n  ) %>%\n  mutate(\n    mod = map2(\n      data, link,\n      ~clmm(\n        rating ~ 1 + contact + temp + (1|judge),\n        data = .x, link = .y\n      )\n    )\n  ) %>%\n  mutate(mod_summary = map(mod, glance)) %>%\n  unnest(mod_summary) %>%\n  select(link, logLik, AIC, BIC) %>%\n  arrange(logLik) %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      link\n      logLik\n      AIC\n      BIC\n    \n  \n  \n    cauchit\n-86.83499\n187.6700\n203.6066\n    cloglog\n-82.72936\n179.4587\n195.3954\n    logit\n-81.56541\n177.1308\n193.0675\n    loglog\n-81.54137\n177.0827\n193.0194\n    probit\n-80.93061\n175.8612\n191.7979\n  \n  \n  \n\n\n\n\nThe probit model appears to be the best description of the data.\nWe can also consider the effect of “flexible” vs “equidistant” thresholds:\n\nwine %>%\n  nest(data = everything()) %>%\n  crossing(\n    link = c(\"logit\", \"probit\", \"cloglog\", \"loglog\", \"cauchit\"),\n    threshold = c(\"flexible\", \"equidistant\")\n  ) %>%\n  mutate(\n    mod = pmap(\n      list(data, link, threshold),\n      function(a, b, c) {\n        clmm(\n          rating ~ 1 + contact + temp + (1|judge),\n          data = a, link = b, threshold = c\n        )\n      }\n    )\n  ) %>%\n  #mutate(mod_summary = map(mod, glance)) %>%\n  mutate(\n    mod_summary = map(\n      mod,\n      # glance() on a clmm object returns a <logLik> variable type which\n      #  can't be bound together by unnest(), so need to convert it to numeric\n      ~glance(.x) %>% mutate(logLik = as.numeric(logLik))\n    )\n  ) %>%\n  unnest(mod_summary) %>%\n  select(link, threshold, logLik, edf, AIC, BIC) %>%\n  arrange(logLik) %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      link\n      threshold\n      logLik\n      edf\n      AIC\n      BIC\n    \n  \n  \n    cauchit\nequidistant\n-87.75021\n5\n185.5004\n196.8837\n    cauchit\nflexible\n-86.83499\n7\n187.6700\n203.6066\n    loglog\nequidistant\n-84.36440\n5\n178.7288\n190.1121\n    cloglog\nequidistant\n-83.32634\n5\n176.6527\n188.0360\n    logit\nequidistant\n-83.05497\n5\n176.1099\n187.4933\n    cloglog\nflexible\n-82.72936\n7\n179.4587\n195.3954\n    probit\nequidistant\n-82.52622\n5\n175.0524\n186.4358\n    logit\nflexible\n-81.56541\n7\n177.1308\n193.0675\n    loglog\nflexible\n-81.54137\n7\n177.0827\n193.0194\n    probit\nflexible\n-80.93061\n7\n175.8612\n191.7979\n  \n  \n  \n\n\n\n\nNote the change in degrees of freedom, resulting in the equidistant probit model having the lowest BIC. In terms of log likelihood, however, flexible always outperform equidistant thresholds."
  },
  {
    "objectID": "posts/2020-03-15-ordinal-regression-in-r-part-1/ordinal-regression-in-r-part-1.html#conclusion",
    "href": "posts/2020-03-15-ordinal-regression-in-r-part-1/ordinal-regression-in-r-part-1.html#conclusion",
    "title": "Ordinal regression in R: part 1",
    "section": "Conclusion",
    "text": "Conclusion\nThanks to detailed documentation, fitting cumulative link (mixed) models is very easy with ordinal. In this post, we first learned the theoretical basis for these models, then worked through examples using wine bitterness ratings from multiple judges.\nIn the next post, I’ll explore the Bayesian approach to ordinal regression with the brms package."
  },
  {
    "objectID": "posts/2020-03-15-ordinal-regression-in-r-part-1/ordinal-regression-in-r-part-1.html#reproducibility",
    "href": "posts/2020-03-15-ordinal-regression-in-r-part-1/ordinal-regression-in-r-part-1.html#reproducibility",
    "title": "Ordinal regression in R: part 1",
    "section": "Reproducibility",
    "text": "Reproducibility\n\n\n\nSession info\n\n\n\n setting  value\n version  R version 4.2.1 (2022-06-23 ucrt)\n os       Windows 10 x64 (build 19044)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Canada.utf8\n ctype    English_Canada.utf8\n tz       America/Curacao\n date     2022-08-07\n pandoc   2.18 @ C:/Program Files/RStudio/bin/quarto/bin/tools/ (via rmarkdown)\n\n\n\n\n  \n\n\n\n\n\n\nGit repository\n\n\n\nLocal:    main C:/Users/tdunn/Documents/tdunn-quarto\nRemote:   main @ origin (https://github.com/taylordunn/tdunn-quarto.git)\nHead:     [53358c7] 2022-08-06: Set fonts and trying out `renv.lock` for reproducibility\n\n\n\n\n\n\nSource code, R environment"
  },
  {
    "objectID": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html",
    "href": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html",
    "title": "Predicting bike ridership: getting the data",
    "section": "",
    "text": "R setup\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(lubridate)\nlibrary(gt)\nlibrary(glue)\n\nlibrary(dunnr)\nextrafont::loadfonts(device = \"win\", quiet = TRUE)\ntheme_set(theme_td())\nset_geom_fonts()\nset_palette()"
  },
  {
    "objectID": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html#introduction",
    "href": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html#introduction",
    "title": "Predicting bike ridership: getting the data",
    "section": "Introduction",
    "text": "Introduction\nIn 2016, the city of Halifax installed its first cyclist tracker on Agricola Street. Last year, the city made bike counter data available on their open data platform. As a cyclist and Haligonian, this is of course interesting to me personally. As a data scientist, this seems like a nice opportunity to work through a machine learning project end-to-end: from retrieving, exploring, and processing the data, to building and evaluating models, to producing an end product. (A REST API? A Shiny app? TBD.)\nIn this post, I get and explore data from two sources: (1) the aforementioned bike counter data from city of Halifax, and (2) historical weather data from the government of Canada."
  },
  {
    "objectID": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html#getting-bicycle-count-data",
    "href": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html#getting-bicycle-count-data",
    "title": "Predicting bike ridership: getting the data",
    "section": "Getting bicycle count data",
    "text": "Getting bicycle count data\nThe bicycle counts were easy enough to find on Halifax’s platform: (https://catalogue-hrm.opendata.arcgis.com/datasets/45d4ecb0cb48469186e683ebc54eb188_0/explore?showTable=true). Each data set comes with a nice API explorer for constructing queries. I’ll use httr to GET the data with the basic query provided there:\n\nquery_url <- \"https://services2.arcgis.com/11XBiaBYA9Ep0yNJ/arcgis/rest/services/Bicycle_Counts/FeatureServer/0/query?where=1%3D1&outFields=*&outSR=4326&f=json\"\nresp <- httr::GET(query_url)\nresp\n\n\n\nResponse [https://services2.arcgis.com/11XBiaBYA9Ep0yNJ/arcgis/rest/services/Bicycle_Counts/FeatureServer/0/query?where=1%3D1&outFields=*&outSR=4326&f=json]\n  Date: 2022-04-27 03:26\n  Status: 200\n  Content-Type: application/json; charset=utf-8\n  Size: 579 kB\n\n\nThe response code (200) indicates a successful connection. The data comes in JSON format, which I can parse to an R list with:\n\nparsed_content <- content(resp, as = \"parsed\")\nstr(parsed_content, max.level = 1)\n\nList of 6\n $ objectIdFieldName    : chr \"ObjectId\"\n $ uniqueIdField        :List of 2\n $ globalIdFieldName    : chr \"\"\n $ fields               :List of 11\n $ exceededTransferLimit: logi TRUE\n $ features             :List of 2000\n\n\nThis returned a list of 6 items. The fields item is a list of variables:\n\nfields <- map_dfr(\n  parsed_content$fields,\n  # Drop NULL elements so I can convert to a tibble\n  ~ discard(.x, is.null) %>% as_tibble()\n)\ngt(fields)\n\n\n\n\n\n  \n  \n    \n      name\n      type\n      alias\n      sqlType\n      length\n    \n  \n  \n    CHANNEL_ID\nesriFieldTypeString\nCHANNEL_ID\nsqlTypeNVarchar\n256\n    CHANNEL_NAME\nesriFieldTypeString\nCHANNEL_NAME\nsqlTypeNVarchar\n4000\n    SERIAL_NUMBER\nesriFieldTypeString\nSERIAL_NUMBER\nsqlTypeNVarchar\n4000\n    SITE_NAME\nesriFieldTypeString\nSITE_NAME\nsqlTypeNVarchar\n4000\n    LATITUDE\nesriFieldTypeDouble\nLATITUDE\nsqlTypeFloat\nNA\n    LONGITUDE\nesriFieldTypeDouble\nLONGITUDE\nsqlTypeFloat\nNA\n    INSTALLATION_DATE\nesriFieldTypeDate\nINSTALLATION_DATE\nsqlTypeTimestamp2\n8\n    COUNT_DATETIME\nesriFieldTypeDate\nCOUNT_DATETIME\nsqlTypeTimestamp2\n8\n    COUNTER_TYPE\nesriFieldTypeString\nCOUNTER_TYPE\nsqlTypeNVarchar\n4000\n    COUNTER_VALUE\nesriFieldTypeInteger\nCOUNTER_VALUE\nsqlTypeInteger\nNA\n    ObjectId\nesriFieldTypeOID\nObjectId\nsqlTypeInteger\nNA\n  \n  \n  \n\n\n\n\nThe data is the features item, which itself is a list of length 2000. Here is the first element:\n\nparsed_content$features[[1]]\n\n$attributes\n$attributes$CHANNEL_ID\n[1] \"100059339\"\n\n$attributes$CHANNEL_NAME\n[1] \"Hollis St\"\n\n$attributes$SERIAL_NUMBER\n[1] \"X2H20032465\"\n\n$attributes$SITE_NAME\n[1] \"Hollis St\"\n\n$attributes$LATITUDE\n[1] 44.64799\n\n$attributes$LONGITUDE\n[1] -63.57352\n\n$attributes$INSTALLATION_DATE\n[1] 1.594166e+12\n\n$attributes$COUNT_DATETIME\n[1] 1.595966e+12\n\n$attributes$COUNTER_TYPE\n[1] \"Bicycle\"\n\n$attributes$COUNTER_VALUE\n[1] 2\n\n$attributes$ObjectId\n[1] 1\n\n\nLooks like there is another level of nesting with attributes. Compile all of these elements into a single data frame:\n\nbike_counts <- map_dfr(\n  parsed_content$features,\n  ~ as_tibble(.x$attributes)\n)\nglimpse(bike_counts)\n\nRows: 2,000\nColumns: 11\n$ CHANNEL_ID        <chr> \"100059339\", \"100059339\", \"100059339\", \"100059339\", …\n$ CHANNEL_NAME      <chr> \"Hollis St\", \"Hollis St\", \"Hollis St\", \"Hollis St\", …\n$ SERIAL_NUMBER     <chr> \"X2H20032465\", \"X2H20032465\", \"X2H20032465\", \"X2H200…\n$ SITE_NAME         <chr> \"Hollis St\", \"Hollis St\", \"Hollis St\", \"Hollis St\", …\n$ LATITUDE          <dbl> 44.64799, 44.64799, 44.64799, 44.64799, 44.64799, 44…\n$ LONGITUDE         <dbl> -63.57352, -63.57352, -63.57352, -63.57352, -63.5735…\n$ INSTALLATION_DATE <dbl> 1.594166e+12, 1.594166e+12, 1.594166e+12, 1.594166e+…\n$ COUNT_DATETIME    <dbl> 1.595966e+12, 1.595970e+12, 1.595974e+12, 1.595977e+…\n$ COUNTER_TYPE      <chr> \"Bicycle\", \"Bicycle\", \"Bicycle\", \"Bicycle\", \"Bicycle…\n$ COUNTER_VALUE     <int> 2, 1, 2, 2, 0, 0, 0, 0, 0, 0, 6, 4, 13, 8, 5, 6, 8, …\n$ ObjectId          <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n\n\nNote that just 2000 records were returned. The exceededTransferLimit = TRUE value tells us that this is the limit of the API. I can get the total count of records by altering the original query slightly:\n\nn_records <- httr::GET(paste0(query_url, \"&returnCountOnly=true\")) %>%\n  content(as = \"parsed\") %>%\n  unlist(use.names = FALSE)\nn_records\n\n\n\n[1] 124356\n\n\nSo to get all of the data at 2000 records per request, I’ll have to make a minimum of 63 calls to the API. The API offers a “resultOffset” argument to get records in sequence. Make a function to get 2000 records for a given offset:\n\nget_bike_data <- function(offset) {\n  # Need to prevent scientific notation, e.g. \"1e+05\" instead of \"100000\"\n  offset <- format(offset, scientific = FALSE)\n  \n  parsed_content <- httr::GET(paste0(query_url, \"&resultOffset=\", offset)) %>%\n    content(as = \"parsed\")\n  \n  map_dfr(\n    parsed_content$features,\n    ~ as_tibble(.x$attributes)\n  ) \n}\n\nAnd combine it all into a single data frame:\n\nbike_data <- map_dfr(\n  seq(0, ceiling(n_records / 2000)),\n  ~ get_bike_data(offset = .x * 2000)\n)\n\n\n\n\n\nglimpse(bike_data)\n\nRows: 124,356\nColumns: 11\n$ CHANNEL_ID        <chr> \"100059339\", \"100059339\", \"100059339\", \"100059339\", …\n$ CHANNEL_NAME      <chr> \"Hollis St\", \"Hollis St\", \"Hollis St\", \"Hollis St\", …\n$ SERIAL_NUMBER     <chr> \"X2H20032465\", \"X2H20032465\", \"X2H20032465\", \"X2H200…\n$ SITE_NAME         <chr> \"Hollis St\", \"Hollis St\", \"Hollis St\", \"Hollis St\", …\n$ LATITUDE          <dbl> 44.64799, 44.64799, 44.64799, 44.64799, 44.64799, 44…\n$ LONGITUDE         <dbl> -63.57352, -63.57352, -63.57352, -63.57352, -63.5735…\n$ INSTALLATION_DATE <dbl> 1.594166e+12, 1.594166e+12, 1.594166e+12, 1.594166e+…\n$ COUNT_DATETIME    <dbl> 1.595966e+12, 1.595970e+12, 1.595974e+12, 1.595977e+…\n$ COUNTER_TYPE      <chr> \"Bicycle\", \"Bicycle\", \"Bicycle\", \"Bicycle\", \"Bicycle…\n$ COUNTER_VALUE     <int> 2, 1, 2, 2, 0, 0, 0, 0, 0, 0, 6, 4, 13, 8, 5, 6, 8, …\n$ ObjectId          <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n\n\nThis returned 124356 records, as expected. The ObjectId should be a unique sequential identifier from 1 to 124356, which I’ll check:\n\nrange(bike_data$ObjectId); n_distinct(bike_data$ObjectId)\n\n[1]      1 124356\n\n\n[1] 124356\n\n\n\nEDA and cleaning\nFirst thing I usually do with a new data set is clean the column names:\n\nbike_data <- janitor::clean_names(bike_data)\nglimpse(bike_data)\n\nRows: 124,356\nColumns: 11\n$ channel_id        <chr> \"100059339\", \"100059339\", \"100059339\", \"100059339\", …\n$ channel_name      <chr> \"Hollis St\", \"Hollis St\", \"Hollis St\", \"Hollis St\", …\n$ serial_number     <chr> \"X2H20032465\", \"X2H20032465\", \"X2H20032465\", \"X2H200…\n$ site_name         <chr> \"Hollis St\", \"Hollis St\", \"Hollis St\", \"Hollis St\", …\n$ latitude          <dbl> 44.64799, 44.64799, 44.64799, 44.64799, 44.64799, 44…\n$ longitude         <dbl> -63.57352, -63.57352, -63.57352, -63.57352, -63.5735…\n$ installation_date <dbl> 1.594166e+12, 1.594166e+12, 1.594166e+12, 1.594166e+…\n$ count_datetime    <dbl> 1.595966e+12, 1.595970e+12, 1.595974e+12, 1.595977e+…\n$ counter_type      <chr> \"Bicycle\", \"Bicycle\", \"Bicycle\", \"Bicycle\", \"Bicycle…\n$ counter_value     <int> 2, 1, 2, 2, 0, 0, 0, 0, 0, 0, 6, 4, 13, 8, 5, 6, 8, …\n$ object_id         <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n\n\nNext I want to deal with the installation_date and count_datetime variables, which are very large integers. From fields above, the data type for these variables is esriFieldTypeDate. After some digging on Google, turns out this is Unix time (the number of milliseconds since January 1, 1970; also called epoch time). With as.POSIXct(), I can supply the number of seconds and set origin = \"1970-01-01\" to get back the correct datetime objects:\n\nbike_data <- bike_data %>%\n  mutate(\n    across(c(installation_date, count_datetime),\n           ~ as.POSIXct(.x / 1000, tz = \"UTC\", origin = \"1970-01-01\")),\n    # These are just dates, the time of day doesn't matter\n    installation_date = as.Date(installation_date),\n    # I'll also want the date without time of day\n    count_date = as.Date(count_datetime)\n  )\n\nThese variables are unique to the sites:\n\nbike_data %>%\n  count(site_name, latitude, longitude, serial_number, installation_date,\n        counter_type, name = \"n_records\") %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      site_name\n      latitude\n      longitude\n      serial_number\n      installation_date\n      counter_type\n      n_records\n    \n  \n  \n    Dartmouth Harbourfront Greenway\n44.66436\n-63.55736\nX2H20114473\n2021-07-08\nBicycle\n13976\n    Hollis St\n44.64799\n-63.57352\nX2H20032465\n2020-07-08\nBicycle\n15748\n    South Park St\n44.64194\n-63.57972\nX2H19070467\n2019-09-01\nBicycle\n46424\n    Vernon St\n44.64292\n-63.59154\nX2H20114470\n2020-12-09\nBicycle\n24104\n    Windsor St\n44.65466\n-63.60368\nX2H20114472\n2020-12-09\nBicycle\n24104\n  \n  \n  \n\n\n\n\nDrop serial_number and counter_type, which aren’t useful.\n\nbike_data <- bike_data %>% select(-serial_number, -counter_type)\n\nSites can have multiple channels:\n\nbike_data %>%\n  count(site_name, channel_name, channel_id, name = \"n_records\") %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      site_name\n      channel_name\n      channel_id\n      n_records\n    \n  \n  \n    Dartmouth Harbourfront Greenway\nDartmouth Harbourfront Greenway Northbound\n353280085\n6988\n    Dartmouth Harbourfront Greenway\nDartmouth Harbourfront Greenway Southbound\n353280086\n6988\n    Hollis St\nHollis St\n100059339\n15748\n    South Park St\nSouth Park St Northbound\n101054257\n23212\n    South Park St\nSouth Park St Southbound\n102054257\n23212\n    Vernon St\nVernon St Northbound\n353252897\n12052\n    Vernon St\nVernon St Southbound\n353252898\n12052\n    Windsor St\nWindsor St Northbound\n353252910\n12052\n    Windsor St\nWindsor St Southbound\n353252909\n12052\n  \n  \n  \n\n\n\n\nAll but the Hollis St site has separate northbound and southbound channels.\nFor each site, check the installation_date relative to the range of count_date:\n\nbike_data %>%\n  group_by(site_name, installation_date) %>%\n  summarise(min_count_date = min(count_date), max_count_date = max(count_date),\n            .groups = \"drop\") %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      site_name\n      installation_date\n      min_count_date\n      max_count_date\n    \n  \n  \n    Dartmouth Harbourfront Greenway\n2021-07-08\n2021-07-08\n2022-04-25\n    Hollis St\n2020-07-08\n2020-07-08\n2022-04-25\n    South Park St\n2019-09-01\n2019-09-01\n2022-04-25\n    Vernon St\n2020-12-09\n2020-12-09\n2022-04-25\n    Windsor St\n2020-12-09\n2020-12-09\n2022-04-25\n  \n  \n  \n\n\n\n\nEverything is nicely aligned: the first data corresponds to the installation date, and the last data corresponds to the date the data were retrieved.\nPlot the position of each of the counters using the given latitude and longitude, overlaid on a map of Halifax with the ggmap package:1\n\nlibrary(ggmap)\nsite_locs <- bike_data %>%\n  distinct(site_name, lat = latitude, lon = longitude)\n\nmean_lat <- mean(site_locs$lat)\nmean_lon <- mean(site_locs$lon)\n\n\nhalifax_map <- get_googlemap(c(mean_lon, mean_lat),\n                             zoom = 14, maptype = \"satellite\")\n\n\n\n\n\nggmap(halifax_map) +\n  geom_point(data = site_locs, size = 4,\n             aes(fill = site_name), shape = 21, color = \"white\") +\n  ggrepel::geom_label_repel(\n    data = site_locs,\n    aes(color = site_name, label = str_trunc(site_name, width = 25)),\n    box.padding = 1.0\n  ) +\n  theme_void() +\n  theme(legend.position = \"none\")\n\n\n\n\nFor each site and channel, get the time of day from count_datetime to determine the frequency of collection:\n\nbike_data %>%\n  mutate(time_of_day = format(count_datetime, \"%H:%M:%S\")) %>%\n  count(site_name, time_of_day, name = \"n_records\") %>%\n  ggplot(aes(y = time_of_day, x = n_records)) +\n  geom_col() +\n  facet_wrap(~ str_trunc(site_name, 15), nrow = 1) +\n  scale_x_continuous(expand = c(0, 0), breaks = c(0, 500, 1000, 1500)) +\n  dunnr::add_facet_borders()\n\n\n\n\nEach counter reports observations at the hour mark (+1 second). There are some slight difference in the number of records due to the time of day I retrieved the data.\nI made an assumption that the count_datetime variable was in UTC timezone. I can check this assumption by looking at average counts (over the entire data set).\n\nbike_data_tod <- bike_data %>%\n  mutate(\n    time_of_day = format(count_datetime, \"%H:%M:%S\"),\n    # Create a dummy variable with arbitrary date so I can plot time of day\n    time_of_day = lubridate::ymd_hms(\n      paste0(\"2022-04-22 \", time_of_day)\n    )\n  )\nbike_data_tod %>%\n  group_by(site_name, time_of_day) %>%\n  summarise(\n    n = n(), mean_count = mean(counter_value),\n    .groups = \"drop\"\n  ) %>%\n  ggplot(aes(x = time_of_day, y = mean_count)) +\n  geom_area(fill = td_colors$nice$mellow_yellow, color = \"black\") +\n  facet_wrap(~ site_name, ncol = 1, scales = \"free_y\") +\n  scale_x_datetime(date_breaks = \"2 hours\", date_labels = \"%H\") +\n  scale_y_continuous(expand = c(0, 0)) +\n  dunnr::add_facet_borders()\n\n\n\n\nThese peaks at around 8AM and 5PM tell me that the data is actually recorded in the local time zone (Atlantic), not UTC like I assumed. If they were in UTC time, the peaks would correspond to 11AM and 8PM locally, which would be odd times for peak cyclists.\nAny interesting trends in different channels?\n\nbike_data_tod %>%\n  # Remove Hollis St, which does not have different channels\n  filter(site_name != \"Hollis St\") %>%\n  mutate(channel_direction = str_extract(channel_name, \"(North|South)bound\")) %>%\n  group_by(site_name, channel_direction, time_of_day) %>%\n  summarise(mean_count = mean(counter_value), .groups = \"drop\") %>%\n  ggplot(aes(x = time_of_day, y = mean_count, color = channel_direction)) +\n  geom_line() +\n  facet_wrap(~ site_name, ncol = 1, scales = \"free_y\") +\n  scale_x_datetime(date_breaks = \"2 hours\", date_labels = \"%H\") +\n  theme(legend.position = \"top\")\n\n\n\n\nVernon St and Windsor St counters have higher traffic Southbound (heading downtown) at the start of the typical workday, and higher traffic Northbound (leaving downtown) at the end of the typical workday.\nI am less interested in counts over the course of a day or by channel, and more interested in daily counts. Now that I know the count_date is correctly converted with the local time, get the sum at each site and each 24 hour day:\n\nbike_data_daily_counts <- bike_data %>%\n  group_by(site_name, installation_date, count_date) %>%\n  summarise(\n    n_records = n(), n_bikes = sum(counter_value), .groups = \"drop\"\n  )\n\nNow plot counts per day at each site:\n\nbike_data_daily_counts %>%\n  ggplot(aes(x = count_date, y = n_bikes)) +\n  geom_line() +\n  facet_wrap(~ site_name, ncol = 1, scales = \"free_y\") +\n  dunnr::add_facet_borders()\n\n\n\n\nThe seasonal trends are very obvious from this plot. One thing that stood out to me is the big increase from 2020 to 2021 on South Park St. It may be representative of the start of the COVID pandemic, but I think it also has to do with the addition of protected bike lanes in December 2020. Before 2020, there appears to be a series of 0 counts on South Park St which may be artifacts:\n\nbike_data_daily_counts %>%\n  filter(site_name == \"South Park St\", count_date < \"2020-01-01\") %>%\n  ggplot(aes(x = count_date, y = n_bikes)) +\n  geom_line()\n\n\n\n\nI’m almost certain this series of zeroes is not real, so I’ll remove it from the data. Find the date of the first non-zero n_bikes at this site, and filter out data before then:\n\nsouth_park_min_date <- bike_data_daily_counts %>%\n  filter(site_name == \"South Park St\", n_bikes > 0) %>%\n  pull(count_date) %>%\n  min()\nsouth_park_min_date\n\n[1] \"2019-11-23\"\n\nbike_data_daily_counts <- bike_data_daily_counts %>%\n  filter(!((site_name == \"South Park St\") & (count_date < south_park_min_date)))\n\nOverlay counts by year for each site:\n\nbike_data_daily_counts %>%\n  mutate(count_year = year(count_date),\n         # Replace year with 1970 so I can plot on the same scale\n         count_date = as.Date(yday(count_date), origin = \"1970-01-01\")) %>%\n  ggplot(aes(x = count_date, y = n_bikes, color = factor(count_year))) +\n  geom_line(size = 1, alpha = 0.8) +\n  facet_wrap(~ site_name, ncol = 1, scales = \"free_y\") +\n  scale_x_date(date_labels = \"%B\") +\n  dunnr::add_facet_borders() +\n  theme(legend.position = \"bottom\") +\n  labs(x = NULL, color = \"Year\") +\n  scale_color_brewer(palette = \"Set1\")\n\n\n\n\nI’m interested in day of the week effects as well:\n\nbike_data_daily_counts %>%\n  mutate(day_of_week = wday(count_date, label = TRUE)) %>%\n  ggplot(aes(y = day_of_week, x = n_bikes)) +\n  geom_boxplot()\n\n\n\n\nLess activity on the weekends."
  },
  {
    "objectID": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html#getting-weather-data",
    "href": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html#getting-weather-data",
    "title": "Predicting bike ridership: getting the data",
    "section": "Getting weather data",
    "text": "Getting weather data\nTemporal data are probably the most important predictors of ridership, but I’m sure a close second is the day’s weather. I’ll get this with the API provided by the Meteorological Service of Canada. I can get a list of available data sets (which they call collections) as follows:2\n\nbase_url <- \"https://api.weather.gc.ca/\"\nresp <- httr::GET(paste0(base_url, \"collections?f=json\"))\n\n\n\n\n\ncontent_parsed <- content(resp, as = \"parsed\")\nstr(content_parsed, max.level = 1)\n\nList of 2\n $ collections:List of 70\n $ links      :List of 3\n\n\nThe first element of collections:\n\ncollections <- content_parsed$collections\nstr(collections[[1]], max.level = 2)\n\nList of 7\n $ id         : chr \"hydrometric-stations\"\n $ title      : chr \"Hydrometric Monitoring Stations\"\n $ description: chr \"A station is a site on a river or lake where water quantity (water level and flow) are collected and recorded.\"\n $ keywords   :List of 2\n  ..$ : chr \"station\"\n  ..$ : chr \"hydrometric station\"\n $ links      :List of 13\n  ..$ :List of 5\n  ..$ :List of 5\n  ..$ :List of 5\n  ..$ :List of 5\n  ..$ :List of 5\n  ..$ :List of 4\n  ..$ :List of 4\n  ..$ :List of 4\n  ..$ :List of 4\n  ..$ :List of 4\n  ..$ :List of 4\n  ..$ :List of 4\n  ..$ :List of 4\n $ extent     :List of 2\n  ..$ spatial :List of 2\n  ..$ temporal:List of 1\n $ itemType   : chr \"feature\"\n\n\nUnlike the bicycle counts data, this nested format doesn’t lend itself well to direct conversion to a tibble:\n\nas_tibble(collections[[1]])\n\nError:\n! Tibble columns must have compatible sizes.\n• Size 2: Columns `keywords` and `extent`.\n• Size 13: Column `links`.\nℹ Only values of size one are recycled.\n\n\nInstead, I can use enframe() to get a two-column data frame:\n\nenframe(collections[[1]])\n\n# A tibble: 7 × 2\n  name        value           \n  <chr>       <list>          \n1 id          <chr [1]>       \n2 title       <chr [1]>       \n3 description <chr [1]>       \n4 keywords    <list [2]>      \n5 links       <list [13]>     \n6 extent      <named list [2]>\n7 itemType    <chr [1]>       \n\n\nAssuming every item in the collections list has the same structure, I’ll just extract the id, title, and description:\n\ncollections_df <-  map_dfr(\n  collections,\n  ~ enframe(.x) %>%\n    filter(name %in% c(\"id\", \"title\", \"description\")) %>%\n    pivot_wider(names_from = name, values_from = value)\n)\ngt(collections_df) %>%\n  tab_options(container.height = 300, container.overflow.y = TRUE)\n\n\n\n\n\n  \n  \n    \n      id\n      title\n      description\n    \n  \n  \n    hydrometric-stations\nHydrometric Monitoring Stations\nA station is a site on a river or lake where water quantity (water level and flow) are collected and recorded.\n    hydrometric-daily-mean\nDaily Mean of Water Level or Flow\nThe daily mean is the average of all unit values for a given day.\n    hydrometric-monthly-mean\nMonthly Mean of Water Level or Flow\nThe monthly mean is the average of daily mean values for a given month.\n    hydrometric-annual-statistics\nAnnual Maximum and Minimum Daily Water Level or Flow\nThe annual maximum and minimum daily data are the maximum and minimum daily mean values for a given year.\n    hydrometric-annual-peaks\nAnnual Maximum and Minimum Instantaneous Water Level or Flow\nThe annual maximum and minimum instantaneous data are the maximum and minimum instantaneous values for a given year.\n    hydrometric-realtime\nReal-time hydrometric data\nReal-time water level and flow (discharge) data collected at over 2100 hydrometric stations across Canada (last 30 days).\n    climate-normals\n1981-2010 Climate Normals\nClimate Normals are used to summarize or describe the average climatic conditions of a particular location. At the completion of each decade, Environment and Climate Change Canada updates its climate normals for as many locations and as many climatic characteristics as possible. The climate normals offered here are based on Canadian climate stations with at least 15 years of data between 1981 to 2010.\n    climate-stations\nClimate Stations\nClimate observations are derived from two sources of data. The first are Daily Climate Stations producing one or two observations per day of temperature, precipitation. The second are hourly stations that typically produce more weather elements e.g. wind or snow on ground.\n    climate-monthly\nMonthly Climate Observation Summaries\nA cross-country summary of the averages and extremes for the month, including precipitation totals, max-min temperatures, and degree days. This data is available from stations that produce daily data.\n    climate-daily\nDaily Climate Observations\nDaily climate observations are derived from two sources of data. The first are Daily Climate Stations producing one or two observations per day of temperature, precipitation. The second are hourly stations that typically produce more weather elements e.g. wind or snow on ground. Only a subset of the total stations is shown due to size limitations. The criteria for station selection are listed as below. The priorities for inclusion are as follows: (1) Station is currently operational, (2) Stations with long periods of record, (3) Stations that are co-located with the categories above and supplement the period of record\n    climate-hourly\nHourly Climate Observations\nHourly climate observations are derived from the data source HLY01. These are stations that produce hourly meteorological observations, taken each hour of the day for the hours 00h-23h, for both daily (temperature, precipitation) and non-daily elements (station pressure, relative humidity, visibility). Only a subset of the total stations are shown due to size limitations. The stations were selected based on the following criteria: (1) Stations near cities with populations greater than 10,000, (2) Stations with long periods of record of at least 30 years of data, (3) Stations selected for the 1991-2020 WMO Normals, (4) Stations with RBCN designation not selected for 1991-2020 WMO Normals, and/or (5) Stations whose sum when joined with co-located/successor stations equates to a period of record of 30 years or greater.\n    ahccd-stations\nAdjusted and Homogenized Canadian Climate Data (AHCCD) Stations\nClimate station datasets that incorporate adjustments (derived from statistical procedures) to the original historical station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation.\n    ahccd-annual\nAdjusted and Homogenized Canadian Climate Data (AHCCD) Annual\nAdjusted and Homogenized Canadian Climate Data (AHCCD) are climate station datasets that incorporate adjustments (derived from statistical procedures) to the original historical station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation. Data are provided for temperature, precipitation, pressure and wind speed. Station trend data are provided when available. Trends are calculated using the Theil-Sen method using the station's full period of available data. The availability of trends will vary by station; if more than 5 consecutive years are missing data or more than 10% of the data within the time series is missing, a trend was not calculated.\n    ahccd-seasonal\nAdjusted and Homogenized Canadian Climate Data (AHCCD) Seasonal\nAdjusted and Homogenized Canadian Climate Data (AHCCD) are climate station datasets that incorporate adjustments (derived from statistical procedures) to the original historical station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation. Data are provided for temperature, precipitation, pressure and wind speed. Station trend data are provided when available. Trends are calculated using the Theil-Sen method using the station's full period of available data. The availability of trends will vary by station; if more than 5 consecutive years are missing data or more than 10% of the data within the time series is missing, a trend was not calculated.\n    ahccd-monthly\nAdjusted and Homogenized Canadian Climate Data (AHCCD) Monthly\nAdjusted and Homogenized Canadian Climate Data (AHCCD) are climate station datasets that incorporate adjustments (derived from statistical procedures) to the original historical station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation. Data are provided for temperature, precipitation, pressure and wind speed. Station trend data are provided when available. Trends are calculated using the Theil-Sen method using the station's full period of available data. The availability of trends will vary by station; if more than 5 consecutive years are missing data or more than 10% of the data within the time series is missing, a trend was not calculated.\n    ahccd-trends\nAdjusted and Homogenized Canadian Climate Data (AHCCD) Trends\nAdjusted and Homogenized Canadian Climate Data (AHCCD) are climate station datasets that incorporate adjustments (derived from statistical procedures) to the original historical station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation. Data are provided for temperature, precipitation, pressure and wind speed. Station trend data are provided when available. Trends are calculated using the Theil-Sen method using the station's full period of available data. The availability of trends will vary by station; if more than 5 consecutive years are missing data or more than 10% of the data within the time series is missing, a trend was not calculated.\n    swob-realtime\nSurface Weather Observations\nSurface Observations measured at the automatic and manual stations of the Environment and Climate Change Canada and partners networks, either for a single station, or for the stations of specific provinces and territories (last 30 days)\n    ltce-stations\nVirtual Climate Stations (LTCE)\nA Virtual Climate station is the result of threading together climate data from proximate current and historical stations to construct a long term threaded data set. For the purpose of identifying and tabulating daily extremes of record for temperature, precipitation and snowfall, the Meteorological Service of Canada has threaded or put together data from closely related stations to compile a long time series of data for about 750 locations in Canada to monitor for record-breaking weather. The length of the time series of virtual stations is often greater than 100 years. A Virtual Climate station is always named for an “Area” rather than a point, e.g. Winnipeg Area, to indicate that the data are drawn from that area(within a 20km radius from the urban center) rather than a single precise location.\n    ltce-temperature\nDaily Extremes of Records (LTCE) – Temperature\nAnomalous weather resulting in Temperature and Precipitation extremes occurs almost every day somewhere in Canada. For the purpose of identifying and tabulating daily extremes of record for temperature, precipitation and snowfall, the Meteorological Service of Canada has threaded or put together data from closely related stations to compile a long time series of data for about 750 locations in Canada to monitor for record-breaking weather. Virtual Climate stations correspond with the city pages of weather.gc.ca. This data provides the daily extremes of record for Temperature for each day of the year. Daily elements include: High Maximum, Low Maximum, High Minimum, Low Minimum.\n    ltce-precipitation\nDaily Extremes of Records (LTCE) – Precipitation\nAnomalous weather resulting in Temperature and Precipitation extremes occurs almost every day somewhere in Canada. For the purpose of identifying and tabulating daily extremes of record for temperature, precipitation and snowfall, the Meteorological Service of Canada has threaded or put together data from closely related stations to compile a long time series of data for about 750 locations in Canada to monitor for record-breaking weather. Virtual Climate stations correspond with the city pages of weather.gc.ca. This data provides the daily extremes of record for Precipitation for each day of the year. Daily elements include: Greatest Precipitation.\n    ltce-snowfall\nDaily Extremes of Records (LTCE) – Snowfall\nAnomalous weather resulting in Temperature and Precipitation extremes occurs almost every day somewhere in Canada. For the purpose of identifying and tabulating daily extremes of record for temperature, precipitation and snowfall, the Meteorological Service of Canada has threaded or put together data from closely related stations to compile a long time series of data for about 750 locations in Canada to monitor for record-breaking weather. Virtual Climate stations correspond with the city pages of weather.gc.ca. This data provides the daily extremes of record for Snowfall for each day of the year. Daily elements include: Greatest Snowfall.\n    aqhi-forecasts-realtime\nAir Quality Health Index – Forecasts\nThe Air Quality Health Index (AQHI) is a scale designed to help quantify the quality of the air in a certain region on a scale from 1 to 10. When the amount of air pollution is very high, the number is reported as 10+. It also includes a category that describes the health risk associated with the index reading (e.g. Low, Moderate, High, or Very High Health Risk). The AQHI is calculated based on the relative risks of a combination of common air pollutants that are known to harm human health, including ground-level ozone, particulate matter, and nitrogen dioxide. The AQHI formulation captures only the short term or acute health risk (exposure of hour or days at a maximum). The formulation of the AQHI may change over time to reflect new understanding associated with air pollution health effects. The AQHI is calculated from data observed in real time, without being verified (quality control).\n    aqhi-observations-realtime\nAir Quality Health Index – Observations\nThe Air Quality Health Index (AQHI) is a scale designed to help quantify the quality of the air in a certain region on a scale from 1 to 10. When the amount of air pollution is very high, the number is reported as 10+. It also includes a category that describes the health risk associated with the index reading (e.g. Low, Moderate, High, or Very High Health Risk). The AQHI is calculated based on the relative risks of a combination of common air pollutants that are known to harm human health, including ground-level ozone, particulate matter, and nitrogen dioxide. The AQHI formulation captures only the short term or acute health risk (exposure of hour or days at a maximum). The formulation of the AQHI may change over time to reflect new understanding associated with air pollution health effects. The AQHI is calculated from data observed in real time, without being verified (quality control).\n    bulletins-realtime\nReal-time meteorological bulletins\nReal-time meteorological bulletins (last 140 days)\n    climate:cmip5:projected:annual:anomaly\nProjected annual anomaly CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:projected:seasonal:anomaly\nProjected seasonal anomaly CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:projected:monthly:anomaly\nProjected monthly anomaly CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:projected:annual:absolute\nProjected annual CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:projected:seasonal:absolute\nProjected seasonal CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:projected:monthly:absolute\nProjected monthly CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:projected:annual:P20Y-Avg\nProjected annual anomaly for 20 years average CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:projected:seasonal:P20Y-Avg\nProjected seasonal anomaly for 20 years average CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:historical:annual:absolute\nHistorical annual CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:historical:annual:anomaly\nHistorical annual anomaly CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:historical:seasonal:absolute\nHistorical seasonal CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:historical:seasonal:anomaly\nHistorical seasonal anomaly CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:historical:monthly:absolute\nHistorical monthly CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:cmip5:historical:monthly:anomaly\nHistorical monthly anomaly CMIP5\nThe Global climate model scenarios dataset is based on an ensemble of global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). Multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios at a 1x1 degree grid resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. A range of percentiles across the multi-model ensembles are available for download.\n    climate:dcs:projected:annual:anomaly\nProjected annual anomaly DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:dcs:projected:seasonal:anomaly\nProjected seasonal anomaly DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:dcs:projected:annual:absolute\nProjected annual DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:dcs:projected:seasonal:absolute\nProjected seasonal DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:dcs:projected:monthly:absolute\nProjected monthly DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:dcs:projected:annual:P20Y-Avg\nProjected annual anomaly for 20 years average DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:dcs:projected:seasonal:P20Y-Avg\nProjected seasonal anomaly for 20 years average DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:dcs:historical:annual:absolute\nHistorical annual DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:dcs:historical:annual:anomaly\nHistorical annual anomaly DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:dcs:historical:seasonal:absolute\nHistorical seasonal DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:dcs:historical:seasonal:anomaly\nHistorical seasonal anomaly DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:dcs:historical:monthly:absolute\nHistorical monthly DCS\nThe statistically downscaled climate scenarios dataset provides multi-model ensembles of modelled output (actual value) and projected change (anomaly) are available for historical simulations and three emission scenarios, RCP2.6, RCP4.5, RCP8.5, at a 10km resolution. Projected changes are expressed as anomalies with respect to the reference period of 1986-2005. Downscaled data are based on global climate model projections from the Coupled Model Intercomparison Project Phase 5 (CMIP5). A range of percentiles across the multi-model ensemble are available for download.\n    climate:indices:historical\nHistorical indices\nHigh-resolution statistically downscaled climate indices relevant to climate change impacts in Canada are available at a 10 km spatial resolution and an annual temporal resolution for 1951-2100. The climate indices are based on model projections from 24 global climate models (GCMs) that participated in the Coupled Model Intercomparison Project Phase 5 (CMIP5).\n    climate:indices:projected\nProjected indices\nHigh-resolution statistically downscaled climate indices relevant to climate change impacts in Canada are available at a 10 km spatial resolution and an annual temporal resolution for 1951-2100. The climate indices are based on model projections from 24 global climate models (GCMs) that participated in the Coupled Model Intercomparison Project Phase 5 (CMIP5).\n    climate:spei-1:historical\nHistorical SPEI-1\nThe Standardized Precipitation Evapotranspiration Index (SPEI) is computed similarly to the SPI. The main difference is that SPI assesses precipitation variance, while SPEI also considers demand from evapotranspiration which is subtracted from any precipitation accumulation prior to assessment. Unlike the SPI, the SPEI captures the main impact of increased temperatures on water demand.\n    climate:spei-3:historical\nHistorical SPEI-3\nThe Standardized Precipitation Evapotranspiration Index (SPEI) is computed similarly to the SPI. The main difference is that SPI assesses precipitation variance, while SPEI also considers demand from evapotranspiration which is subtracted from any precipitation accumulation prior to assessment. Unlike the SPI, the SPEI captures the main impact of increased temperatures on water demand.\n    climate:spei-12:historical\nHistorical SPEI-12\nThe Standardized Precipitation Evapotranspiration Index (SPEI) is computed similarly to the SPI. The main difference is that SPI assesses precipitation variance, while SPEI also considers demand from evapotranspiration which is subtracted from any precipitation accumulation prior to assessment. Unlike the SPI, the SPEI captures the main impact of increased temperatures on water demand.\n    climate:spei-1:projected\nProjected SPEI-1\nThe Standardized Precipitation Evapotranspiration Index (SPEI) is computed similarly to the SPI. The main difference is that SPI assesses precipitation variance, while SPEI also considers demand from evapotranspiration which is subtracted from any precipitation accumulation prior to assessment. Unlike the SPI, the SPEI captures the main impact of increased temperatures on water demand.\n    climate:spei-3:projected\nProjected SPEI-3\nThe Standardized Precipitation Evapotranspiration Index (SPEI) is computed similarly to the SPI. The main difference is that SPI assesses precipitation variance, while SPEI also considers demand from evapotranspiration which is subtracted from any precipitation accumulation prior to assessment. Unlike the SPI, the SPEI captures the main impact of increased temperatures on water demand.\n    climate:spei-12:projected\nProjected SPEI-12\nThe Standardized Precipitation Evapotranspiration Index (SPEI) is computed similarly to the SPI. The main difference is that SPI assesses precipitation variance, while SPEI also considers demand from evapotranspiration which is subtracted from any precipitation accumulation prior to assessment. Unlike the SPI, the SPEI captures the main impact of increased temperatures on water demand.\n    climate:cangrd:historical:annual:trend\nCanGRD historical annual trend\nCANGRD data are interpolated from adjusted and homogenized climate station data (i.e., AHCCD datasets). Homogenized climate data incorporate adjustments to the original station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation. Annual trends of relative total precipitation change (%) for 1948-2012 based on Canadian gridded data (CANGRD) are available, at a 50km resolution across Canada. The relative trends reflect the percent change in total precipitation over a period from the baseline value (defined as the average over 1961-1990 as the reference period). Annual trends of mean surface air temperature change (degrees Celsius) for 1948-2016 based on Canadian gridded data (CANGRD) are available at a 50km resolution across Canada. Temperature trends represent the departure from a mean reference period (1961-1990).\n    climate:cangrd:historical:annual:anomaly\nCanGRD historical annual anomaly\nGridded annual mean temperature anomalies derived from daily minimum, maximum and mean surface air temperatures (degrees Celsius) and anomalies derived from daily total precipitation is available at a 50km resolution across Canada. The Canadian gridded data (CANGRD) are interpolated from homogenized temperature (i.e., AHCCD datasets). Homogenized temperatures incorporate adjustments to the original station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation. The anomalies are the difference between the temperature for a given year or season and a baseline value (defined as the average over 1961-1990 as the reference period). The yearly and seasonal temperature anomalies were computed for the years 1948 to 2017. The data will continue to be updated every year. For precipitation, the Canadian gridded data (CANGRD) are interpolated from adjusted precipitation (i.e., AHCCD datasets). Adjusted precipitation data incorporate adjustments to the original station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation. The anomalies are the percentage difference between the value for a given year or season and a baseline value (defined as the average over 1961-1990 as the reference period). The yearly and seasonal relative precipitation anomalies were computed for the years 1948 to 2014. The data will be updated as time permits.\n    climate:cangrd:historical:monthly:anomaly\nCanGRD historical monthly anomaly\nGridded monthly mean temperature anomalies derived from daily minimum, maximum and mean surface air temperatures (degrees Celsius) and anomalies derived from daily total precipitation is available at a 50km resolution across Canada. The Canadian gridded data (CANGRD) are interpolated from homogenized temperature (i.e., AHCCD datasets). Homogenized temperatures incorporate adjustments to the original station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation. The anomalies are the difference between the temperature for a given year or season and a baseline value (defined as the average over 1961-1990 as the reference period). The yearly and seasonal temperature anomalies were computed for the years 1948 to 2017. The data will continue to be updated every year. For precipitation, the Canadian gridded data (CANGRD) are interpolated from adjusted precipitation (i.e., AHCCD datasets). Adjusted precipitation data incorporate adjustments to the original station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation. The anomalies are the percentage difference between the value for a given year or season and a baseline value (defined as the average over 1961-1990 as the reference period). The yearly and seasonal relative precipitation anomalies were computed for the years 1948 to 2014. The data will be updated as time permits.\n    climate:cangrd:historical:seasonal:trend\nCanGRD historical seasonal trend\nCANGRD data are interpolated from adjusted and homogenized climate station data (i.e., AHCCD datasets). Homogenized climate data incorporate adjustments to the original station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation.Seasonal trends of relative total precipitation change (%) for 1948-2012 based on Canadian gridded data (CANGRD) are available, at a 50km resolution across Canada. The relative trends reflect the percent change in total precipitation over a period from the baseline value (defined as the average over 1961-1990 as the reference period). Seasonal trends of mean surface air temperature change (degrees Celsius) for 1948-2016 based on Canadian gridded data (CANGRD) are available at a 50km resolution across Canada. Temperature trends represent the departure from a mean reference period (1961-1990).\n    climate:cangrd:historical:seasonal:anomaly\nCanGRD historical seasonal anomaly\nGridded seasonal mean temperature anomalies derived from daily minimum, maximum and mean surface air temperatures (degrees Celsius) and anomalies derived from daily total precipitation is available at a 50km resolution across Canada. The Canadian gridded data (CANGRD) are interpolated from homogenized temperature (i.e., AHCCD datasets). Homogenized temperatures incorporate adjustments to the original station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation. The anomalies are the difference between the temperature for a given year or season and a baseline value (defined as the average over 1961-1990 as the reference period). The yearly and seasonal temperature anomalies were computed for the years 1948 to 2017. The data will continue to be updated every year. For precipitation, the Canadian gridded data (CANGRD) are interpolated from adjusted precipitation (i.e., AHCCD datasets). Adjusted precipitation data incorporate adjustments to the original station data to account for discontinuities from non-climatic factors, such as instrument changes or station relocation. The anomalies are the percentage difference between the value for a given year or season and a baseline value (defined as the average over 1961-1990 as the reference period). The yearly and seasonal relative precipitation anomalies were computed for the years 1948 to 2014. The data will be updated as time permits.\n    weather:rdpa:15km:24f\nRegional Deterministic Precipitation Analysis (RDPA) 24 hours accumulation at 15km\nThe Regional Deterministic Precipitation Analysis (RDPA) produces a best estimate of the amount of precipitation that occurred over recent past periods of 24 hours. The estimate integrates data from in situ precipitation gauge measurements, weather radar and numerical weather prediction models. Geographic coverage is North America (Canada, United States and Mexico). Data is available at horizontal resolution of 15 km. Data is only available for the surface level. Analysis data is made available once a day for the 24h intervals. A preliminary estimate is available approximately 1h after the end of the accumulation period, and revised 6h after in order to assimilate gauge data arriving later.\n    weather:rdpa:15km:6f\nRegional Deterministic Precipitation Analysis (RDPA) 6 hours accumulation at 15 km\nThe Regional Deterministic Precipitation Analysis (RDPA) produces a best estimate of the amount of precipitation that occurred over recent past periods of 6 hours. The estimate integrates data from in situ precipitation gauge measurements, weather radar and numerical weather prediction models. Geographic coverage is North America (Canada, United States and Mexico). Data is available at horizontal resolution of 15 km. Data is only available for the surface level. Analysis data is made available four times a day for the 6h intervals. A preliminary estimate is available approximately 1h after the end of the accumulation period, and revised 6h after in order to assimilate gauge data arriving later.\n    weather:rdpa:10km:24f\nRegional Deterministic Precipitation Analysis (RDPA) 24 hours accumulation\nThe Regional Deterministic Precipitation Analysis (RDPA) produces a best estimate of the amount of precipitation that occurred over recent past periods of 24 hours. The estimate integrates data from in situ precipitation gauge measurements, weather radar and numerical weather prediction models. Geographic coverage is North America (Canada, United States and Mexico). Data is available at horizontal resolution of 10 km. Data is only available for the surface level. Analysis data is made available once a day for the 24h intervals. A preliminary estimate is available approximately 1h after the end of the accumulation period, and revised 6h after in order to assimilate gauge data arriving later.\n    weather:rdpa:10km:6f\nRegional Deterministic Precipitation Analysis (RDPA) 6 hours accumulation\nThe Regional Deterministic Precipitation Analysis (RDPA) produces a best estimate of the amount of precipitation that occurred over recent past periods of 6 hours. The estimate integrates data from in situ precipitation gauge measurements, weather radar and numerical weather prediction models. Geographic coverage is North America (Canada, United States and Mexico). Data is available at horizontal resolution of 10 km. Data is only available for the surface level. Analysis data is made available four times a day for the 6h intervals. A preliminary estimate is available approximately 1h after the end of the accumulation period, and revised 6h after in order to assimilate gauge data arriving later.\n    weather:rdpa:10km:24p\nRegional Deterministic Precipitation Analysis (RDPA) 24 hours accumulation (preliminary)\nThe Regional Deterministic Precipitation Analysis (RDPA) produces a best estimate of the amount of precipitation that occurred over recent past periods of 24 hours. The estimate integrates data from in situ precipitation gauge measurements, weather radar and numerical weather prediction models. Geographic coverage is North America (Canada, United States and Mexico). Data is available at horizontal resolution of 10 km. Data is only available for the surface level. Analysis data is made available once a day for the 24h intervals. The preliminary estimate is available approximately 1h after the end of the accumulation period.\n    weather:rdpa:10km:6p\nRegional Deterministic Precipitation Analysis (RDPA) 6 hours accumulation (preliminary)\nThe Regional Deterministic Precipitation Analysis (RDPA) produces a best estimate of the amount of precipitation that occurred over recent past periods of 6 hours. The estimate integrates data from in situ precipitation gauge measurements, weather radar and numerical weather prediction models. Geographic coverage is North America (Canada, United States and Mexico). Data is available at horizontal resolution of 10 km. Data is only available for the surface level. Analysis data is made available four times a day for 6h intervals. The preliminary estimate is available approximately 1h after the end of the accumulation period.\n    weather:cansips:250km:forecast:members\nCanadian Seasonal to Inter-annual Prediction System\nThe Canadian Seasonal to Inter-annual Prediction System (CanSIPS) carries out physics calculations to arrive at probabilistic predictions of atmospheric elements from the beginning of a month out to up to 12 months into the future. Atmospheric elements include temperature, precipitation, wind speed and direction and others. This product contains raw numerical results of these calculations. Geographical coverage is global. Data is available on a grid at a horizontal resolution of 2.5 degrees and for a few selected vertical levels. Predictions and corresponding hindcast are made available monthly.\n  \n  \n  \n\n\n\n\nThe collections I want for this project are climate-stations (to find the appropriate Halifax station) and climate-daily to get daily measurements at that station. Get climate-stations:\n\nresp <- httr::GET(paste0(base_url, \"collections/climate-stations/items?f=json\"))\n\n\n\n\n\ncontent_parsed <- content(resp, as = \"parsed\")\nstr(content_parsed, max.level = 1)\n\nList of 6\n $ type          : chr \"FeatureCollection\"\n $ features      :List of 500\n $ numberMatched : int 8552\n $ numberReturned: int 500\n $ links         :List of 5\n $ timeStamp     : chr \"2022-04-27T03:27:26.475648Z\"\n\n\nBefore looking closer at the data, I can already tell I’ll want to increase the limit of returned entries. From the API documentation, the maximum number is 10000, so I can get all 8552 records in one API call:\n\nresp <- GET(paste0(base_url,\n                   \"collections/climate-stations/items?f=json&limit=10000\"))\n\n\n\n\n\ncontent_parsed <- content(resp, as = \"parsed\")\nstr(content_parsed, max.level = 1)\n\nList of 6\n $ type          : chr \"FeatureCollection\"\n $ features      :List of 8552\n $ numberMatched : int 8552\n $ numberReturned: int 8552\n $ links         :List of 4\n $ timeStamp     : chr \"2022-04-27T03:27:27.265491Z\"\n\n\nThe data is contained in the features list:\n\nclimate_stations <- content_parsed$features\nstr(climate_stations[[1]], max.level = 3)\n\nList of 4\n $ type      : chr \"Feature\"\n $ properties:List of 32\n  ..$ STN_ID                  : int 8496\n  ..$ STATION_NAME            : chr \"CARLETON SUR MER\"\n  ..$ PROV_STATE_TERR_CODE    : chr \"QC\"\n  ..$ ENG_PROV_NAME           : chr \"QUEBEC\"\n  ..$ FRE_PROV_NAME           : chr \"QUÉBEC\"\n  ..$ COUNTRY                 : chr \"CAN\"\n  ..$ LATITUDE                : int 480800000\n  ..$ LONGITUDE               : int -660700000\n  ..$ TIMEZONE                : chr \"EST\"\n  ..$ ELEVATION               : chr \"541.00\"\n  ..$ CLIMATE_IDENTIFIER      : chr \"705AA86\"\n  ..$ TC_IDENTIFIER           : NULL\n  ..$ WMO_IDENTIFIER          : NULL\n  ..$ STATION_TYPE            : chr \"N/A\"\n  ..$ NORMAL_CODE             : NULL\n  ..$ PUBLICATION_CODE        : int 1\n  ..$ DISPLAY_CODE            : int 9\n  ..$ ENG_STN_OPERATOR_ACRONYM: NULL\n  ..$ FRE_STN_OPERATOR_ACRONYM: NULL\n  ..$ ENG_STN_OPERATOR_NAME   : NULL\n  ..$ FRE_STN_OPERATOR_NAME   : NULL\n  ..$ FIRST_DATE              : chr \"1968-10-01 00:00:00\"\n  ..$ LAST_DATE               : chr \"1968-10-31 00:00:00\"\n  ..$ HLY_FIRST_DATE          : NULL\n  ..$ HLY_LAST_DATE           : NULL\n  ..$ DLY_FIRST_DATE          : chr \"1968-10-01 00:00:00\"\n  ..$ DLY_LAST_DATE           : chr \"1968-10-31 00:00:00\"\n  ..$ MLY_FIRST_DATE          : NULL\n  ..$ MLY_LAST_DATE           : NULL\n  ..$ HAS_MONTHLY_SUMMARY     : chr \"Y\"\n  ..$ HAS_NORMALS_DATA        : chr \"N\"\n  ..$ HAS_HOURLY_DATA         : chr \"N\"\n $ geometry  :List of 2\n  ..$ type       : chr \"Point\"\n  ..$ coordinates:List of 2\n  .. ..$ : num -66.1\n  .. ..$ : num 48.1\n $ id        : chr \"705AA86\"\n\n\nAfter some frustration, I found that the geometry$coordinates are the correct latitude/longitude – those in the properties list are slightly off for some reason. Extract the data:\n\nclimate_stations <- map_dfr(\n  climate_stations,\n  ~ discard(.x$properties, is.null) %>% as_tibble() %>%\n    mutate(lat = .x$geometry$coordinates[[2]],\n           lon = .x$geometry$coordinates[[1]])\n) %>%\n  janitor::clean_names() %>%\n  # Drop the incorrect latitude and longitude\n  select(-latitude, -longitude)\n\nglimpse(climate_stations)\n\nRows: 8,552\nColumns: 32\n$ stn_id                   <int> 8496, 9005, 10205, 6149, 6154, 6174, 6177, 61…\n$ station_name             <chr> \"CARLETON SUR MER\", \"PORT COLBORNE (AUT)\", \"K…\n$ prov_state_terr_code     <chr> \"QC\", \"ON\", \"QC\", \"NB\", \"NB\", \"NB\", \"NB\", \"NB…\n$ eng_prov_name            <chr> \"QUEBEC\", \"ONTARIO\", \"QUEBEC\", \"NEW BRUNSWICK…\n$ fre_prov_name            <chr> \"QUÉBEC\", \"ONTARIO\", \"QUÉBEC\", \"NOUVEAU-BRUNS…\n$ country                  <chr> \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CAN\", \"CA…\n$ timezone                 <chr> \"EST\", \"EST\", \"EST\", \"AST\", \"AST\", \"AST\", \"AS…\n$ elevation                <chr> \"541.00\", \"183.50\", \"123.80\", \"152.40\", \"173.…\n$ climate_identifier       <chr> \"705AA86\", \"613F606\", \"7113382\", \"8101178\", \"…\n$ station_type             <chr> \"N/A\", \"Climate-Auto\", \"N/A\", \"N/A\", \"N/A\", \"…\n$ publication_code         <int> 1, NA, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ display_code             <int> 9, NA, NA, 7, 9, 5, 9, 7, 7, 9, 9, 8, 9, 9, 1…\n$ first_date               <chr> \"1968-10-01 00:00:00\", \"1992-12-02 00:00:00\",…\n$ last_date                <chr> \"1968-10-31 00:00:00\", \"2022-04-24 12:30:02\",…\n$ dly_first_date           <chr> \"1968-10-01 00:00:00\", \"1992-12-02 00:00:00\",…\n$ dly_last_date            <chr> \"1968-10-31 00:00:00\", \"2022-04-24 00:00:00\",…\n$ has_monthly_summary      <chr> \"Y\", \"Y\", \"N\", \"Y\", \"Y\", \"Y\", \"Y\", \"Y\", \"Y\", …\n$ has_normals_data         <chr> \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", …\n$ has_hourly_data          <chr> \"N\", \"Y\", \"Y\", \"N\", \"N\", \"N\", \"N\", \"N\", \"N\", …\n$ lat                      <dbl> 48.13333, 42.86667, 60.02306, 45.93333, 47.36…\n$ lon                      <dbl> -66.11667, -79.25000, -70.00361, -64.78333, -…\n$ tc_identifier            <chr> NA, \"WPC\", \"YAS\", NA, NA, NA, NA, NA, NA, NA,…\n$ wmo_identifier           <chr> NA, \"71463\", NA, NA, NA, NA, NA, NA, NA, NA, …\n$ eng_stn_operator_acronym <chr> NA, \"ECCC - MSC\", \"DND\", NA, NA, NA, NA, NA, …\n$ fre_stn_operator_acronym <chr> NA, \"ECCC - SMC\", \"MDN\", NA, NA, NA, NA, NA, …\n$ eng_stn_operator_name    <chr> NA, \"Environment and Climate Change Canada - …\n$ fre_stn_operator_name    <chr> NA, \"Environnement et Changement climatique C…\n$ hly_first_date           <chr> NA, \"1994-02-01 02:00:00\", \"1992-10-21 07:00:…\n$ hly_last_date            <chr> NA, \"2022-04-24 12:30:02\", \"2015-09-10 13:00:…\n$ mly_first_date           <chr> NA, \"2006-04-01 00:00:00\", NA, \"1964-01-01 00…\n$ mly_last_date            <chr> NA, \"2006-12-01 00:00:00\", NA, \"1979-12-01 00…\n$ normal_code              <chr> NA, NA, NA, \"F\", NA, \"D\", NA, \"F\", \"F\", NA, N…\n\n\nNow I’ll filter this list down to those in Halifax, NS using distance to the bike counter latitude/longitude means:\n\nclimate_stations_halifax <- climate_stations %>%\n  filter(prov_state_terr_code == \"NS\") %>%\n  mutate(\n    # Compare to the mean lat/lon from the bike counters\n    diff_lat = abs(lat - mean_lat), diff_lon = abs(lon - mean_lon),\n    # Use squared distance to determine the closest points\n    diff2 = diff_lat^2 + diff_lon^2\n  ) %>%\n  # Look at the top 5 for now\n  slice_min(diff2, n = 5)\n\nclimate_stations_halifax %>% rmarkdown::paged_table()\n\n\n\n  \n\n\n\nVisualize the locations of the stations and bike counters:\n\nd <- bind_rows(\n  site_locs %>% mutate(group = \"bike counters\", label = site_name),\n  climate_stations_halifax %>%\n    transmute(label = glue(\"{station_name} ({stn_id})\"),\n              lat, lon, diff2, group = \"climate stations\")\n)\n  \nggmap(halifax_map) +\n  geom_point(data = d, size = 4,\n             aes(fill = group), shape = 21, color = \"white\") +\n  ggrepel::geom_label_repel(\n    data = d,\n    aes(color = group, label = str_trunc(label, width = 25)),\n    box.padding = 2\n  ) +\n  theme_void() +\n  theme(legend.position = \"none\")\n\n\n\n\nHalifax Citadel is the closest to the center, but last_date is 2002-01-31 for this station, so it hasn’t been active for the past two decades. The next closest is the dockyard, which is actively being updated (last_date is 2022-04-24).\nNow with the station name (“HALIFAX DOCKYARD”), I can request the daily climate reports:\n\nresp <- GET(\n  paste0(\n    base_url,\n    \"collections/climate-daily/items?f=json&limit=10000&STATION_NAME=HALIFAX%20DOCKYARD\"\n  )\n)\n\n\n\n\n\ncontent_parsed <- content(resp, as = \"parsed\")\nstr(content_parsed, max.level = 1)\n\nList of 6\n $ type          : chr \"FeatureCollection\"\n $ features      :List of 1399\n $ numberMatched : int 1399\n $ numberReturned: int 1399\n $ links         :List of 4\n $ timeStamp     : chr \"2022-04-27T03:27:56.527206Z\"\n\n\nThe features data:\n\ndaily_climate <- content_parsed$features\nstr(daily_climate[[1]])\n\nList of 4\n $ id        : chr \"8202240.2021.2.11\"\n $ type      : chr \"Feature\"\n $ geometry  :List of 2\n  ..$ coordinates:List of 2\n  .. ..$ : num -63.6\n  .. ..$ : num 44.7\n  ..$ type       : chr \"Point\"\n $ properties:List of 34\n  ..$ STATION_NAME            : chr \"HALIFAX DOCKYARD\"\n  ..$ CLIMATE_IDENTIFIER      : chr \"8202240\"\n  ..$ ID                      : chr \"8202240.2021.2.11\"\n  ..$ LOCAL_DATE              : chr \"2021-02-11 00:00:00\"\n  ..$ PROVINCE_CODE           : chr \"NS\"\n  ..$ LOCAL_YEAR              : int 2021\n  ..$ LOCAL_MONTH             : int 2\n  ..$ LOCAL_DAY               : int 11\n  ..$ MEAN_TEMPERATURE        : num -7.5\n  ..$ MEAN_TEMPERATURE_FLAG   : NULL\n  ..$ MIN_TEMPERATURE         : num -9.9\n  ..$ MIN_TEMPERATURE_FLAG    : NULL\n  ..$ MAX_TEMPERATURE         : num -5.1\n  ..$ MAX_TEMPERATURE_FLAG    : NULL\n  ..$ TOTAL_PRECIPITATION     : NULL\n  ..$ TOTAL_PRECIPITATION_FLAG: NULL\n  ..$ TOTAL_RAIN              : NULL\n  ..$ TOTAL_RAIN_FLAG         : NULL\n  ..$ TOTAL_SNOW              : NULL\n  ..$ TOTAL_SNOW_FLAG         : NULL\n  ..$ SNOW_ON_GROUND          : NULL\n  ..$ SNOW_ON_GROUND_FLAG     : NULL\n  ..$ DIRECTION_MAX_GUST      : int 28\n  ..$ DIRECTION_MAX_GUST_FLAG : NULL\n  ..$ SPEED_MAX_GUST          : int 47\n  ..$ SPEED_MAX_GUST_FLAG     : NULL\n  ..$ COOLING_DEGREE_DAYS     : int 0\n  ..$ COOLING_DEGREE_DAYS_FLAG: NULL\n  ..$ HEATING_DEGREE_DAYS     : num 25.5\n  ..$ HEATING_DEGREE_DAYS_FLAG: NULL\n  ..$ MIN_REL_HUMIDITY        : int 41\n  ..$ MIN_REL_HUMIDITY_FLAG   : NULL\n  ..$ MAX_REL_HUMIDITY        : int 66\n  ..$ MAX_REL_HUMIDITY_FLAG   : NULL\n\n\nUnfortunately, this station does not report some helpful measurements, like precipitation and snowfall. I might have to expand my search to find a more informative station:\n\nclimate_stations_halifax <- climate_stations %>%\n  filter(prov_state_terr_code == \"NS\",\n         # Only include stations with recent data\n         last_date > \"2022-04-21\") %>%\n  mutate(\n    diff_lat = abs(lat - mean_lat), diff_lon = abs(lon - mean_lon),\n    diff2 = diff_lat^2 + diff_lon^2\n  ) %>%\n  slice_min(diff2, n = 5)\n\nclimate_stations_halifax %>% rmarkdown::paged_table()\n\n\n\n  \n\n\n\nVisualize these station locations in a zoomed out map:\n\nhrm_map <- get_googlemap(c(mean_lon, mean_lat),\n                         zoom = 12, maptype = \"satellite\")\n\n\n\n\n\nd <- bind_rows(\n  site_locs %>% mutate(group = \"bike counters\", label = site_name),\n  climate_stations_halifax %>%\n    #filter(station_name == \"HALIFAX WINDSOR PARK\")\n    transmute(label = glue(\"{station_name} ({stn_id})\"),\n              lat, lon, diff2, group = \"climate stations\")\n)\n  \nggmap(hrm_map) +\n  geom_point(data = d, size = 4,\n             aes(fill = group), shape = 21, color = \"white\") +\n  ggrepel::geom_label_repel(\n    data = d,\n    aes(color = group, label = str_trunc(label, width = 25)),\n    box.padding = 0.5, force = 1.5\n  ) +\n  theme_void() +\n  theme(legend.position = \"none\")\n\n\n\n\nExploring the data from these stations a bit (not shown), Halifax Windsor Park seems a reasonable choice in terms of available data.\n\nresp <- GET(\n  paste0(base_url,\n         \"collections/climate-daily/items?f=json&limit=10000&STATION_NAME=\",\n         URLencode(\"HALIFAX WINDSOR PARK\"))\n)\n\n\n\n\n\ncontent_parsed <- content(resp, as = \"parsed\")\n\ndaily_climate <- map_dfr(\n  content_parsed$features,\n  ~ discard(.x$properties, is.null) %>% as_tibble()\n) %>%\n  janitor::clean_names()\n\nglimpse(daily_climate)\n\nRows: 1,431\nColumns: 29\n$ station_name             <chr> \"HALIFAX WINDSOR PARK\", \"HALIFAX WINDSOR PARK…\n$ climate_identifier       <chr> \"8202255\", \"8202255\", \"8202255\", \"8202255\", \"…\n$ id                       <chr> \"8202255.2021.2.11\", \"8202255.2021.2.12\", \"82…\n$ local_date               <chr> \"2021-02-11 00:00:00\", \"2021-02-12 00:00:00\",…\n$ province_code            <chr> \"NS\", \"NS\", \"NS\", \"NS\", \"NS\", \"NS\", \"NS\", \"NS…\n$ local_year               <int> 2021, 2021, 2021, 2021, 2021, 2018, 2018, 201…\n$ local_month              <int> 2, 2, 2, 2, 2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, …\n$ local_day                <int> 11, 12, 13, 14, 15, 14, 15, 16, 17, 18, 19, 2…\n$ mean_temperature         <dbl> -8.1, -8.1, -5.2, -5.0, -1.5, 10.8, 12.1, 9.0…\n$ min_temperature          <dbl> -11.1, -13.0, -8.0, -8.9, -5.4, 5.0, 9.1, 5.4…\n$ max_temperature          <dbl> -5.2, -3.2, -2.3, -1.2, 2.4, 16.5, 15.1, 12.5…\n$ snow_on_ground           <int> 13, 12, 11, 11, 11, NA, NA, NA, NA, NA, NA, N…\n$ direction_max_gust       <int> 26, 30, NA, NA, NA, 22, 21, 33, NA, NA, NA, 2…\n$ speed_max_gust           <int> 42, 32, NA, NA, NA, 38, 48, 32, NA, NA, NA, 4…\n$ cooling_degree_days      <dbl> 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, …\n$ heating_degree_days      <dbl> 26.1, 26.1, 23.2, 23.0, 19.5, 7.2, 5.9, 9.0, …\n$ min_rel_humidity         <int> 39, 66, 52, 67, 40, 37, 68, 40, 38, 21, 30, 8…\n$ max_rel_humidity         <int> 68, 87, 90, 90, 83, 90, 96, 87, 97, 89, 96, 9…\n$ total_precipitation_flag <chr> NA, NA, NA, NA, \"M\", NA, NA, NA, NA, NA, NA, …\n$ total_precipitation      <dbl> NA, NA, NA, NA, NA, 0.0, 0.6, 0.0, 0.0, 0.0, …\n$ mean_temperature_flag    <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ min_temperature_flag     <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ max_temperature_flag     <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ direction_max_gust_flag  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ speed_max_gust_flag      <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ cooling_degree_days_flag <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ heating_degree_days_flag <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ min_rel_humidity_flag    <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ max_rel_humidity_flag    <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n\n\n\nEDA and cleaning\nVariable summaries:\n\nskimr::skim(daily_climate)\n\n\nData summary\n\n\nName\ndaily_climate\n\n\nNumber of rows\n1431\n\n\nNumber of columns\n29\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\ncharacter\n15\n\n\nnumeric\n14\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: character\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmin\nmax\nempty\nn_unique\nwhitespace\n\n\n\n\nstation_name\n0\n1.00\n20\n20\n0\n1\n0\n\n\nclimate_identifier\n0\n1.00\n7\n7\n0\n1\n0\n\n\nid\n0\n1.00\n16\n18\n0\n1431\n0\n\n\nlocal_date\n0\n1.00\n19\n19\n0\n1431\n0\n\n\nprovince_code\n0\n1.00\n2\n2\n0\n1\n0\n\n\ntotal_precipitation_flag\n1098\n0.23\n1\n1\n0\n1\n0\n\n\nmean_temperature_flag\n1412\n0.01\n1\n1\n0\n1\n0\n\n\nmin_temperature_flag\n1412\n0.01\n1\n1\n0\n1\n0\n\n\nmax_temperature_flag\n1412\n0.01\n1\n1\n0\n1\n0\n\n\ndirection_max_gust_flag\n1412\n0.01\n1\n1\n0\n1\n0\n\n\nspeed_max_gust_flag\n1412\n0.01\n1\n1\n0\n1\n0\n\n\ncooling_degree_days_flag\n1412\n0.01\n1\n1\n0\n1\n0\n\n\nheating_degree_days_flag\n1412\n0.01\n1\n1\n0\n1\n0\n\n\nmin_rel_humidity_flag\n1412\n0.01\n1\n1\n0\n1\n0\n\n\nmax_rel_humidity_flag\n1409\n0.02\n1\n1\n0\n1\n0\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nlocal_year\n0\n1.00\n2019.83\n1.20\n2018.0\n2019.0\n2020.0\n2021.00\n2022.0\n▅▇▇▇▂\n\n\nlocal_month\n0\n1.00\n6.59\n3.44\n1.0\n4.0\n7.0\n10.00\n12.0\n▇▅▅▅▇\n\n\nlocal_day\n0\n1.00\n15.85\n8.76\n1.0\n8.0\n16.0\n23.00\n31.0\n▇▇▇▇▆\n\n\nmean_temperature\n19\n0.99\n8.51\n9.16\n-13.5\n1.3\n8.2\n16.30\n26.8\n▂▆▇▇▅\n\n\nmin_temperature\n19\n0.99\n4.12\n8.95\n-17.3\n-2.1\n3.9\n11.93\n20.7\n▂▅▇▆▆\n\n\nmax_temperature\n19\n0.99\n12.90\n9.66\n-11.0\n5.0\n12.9\n21.20\n34.1\n▂▇▇▇▃\n\n\nsnow_on_ground\n1061\n0.26\n2.82\n4.07\n0.0\n0.0\n1.0\n3.00\n24.0\n▇▁▁▁▁\n\n\ndirection_max_gust\n554\n0.61\n23.77\n8.16\n1.0\n21.0\n24.0\n30.00\n36.0\n▂▃▅▇▆\n\n\nspeed_max_gust\n554\n0.61\n42.48\n10.34\n31.0\n35.0\n40.0\n47.00\n96.0\n▇▂▁▁▁\n\n\ncooling_degree_days\n19\n0.99\n0.61\n1.48\n0.0\n0.0\n0.0\n0.00\n8.8\n▇▁▁▁▁\n\n\nheating_degree_days\n19\n0.99\n10.10\n8.32\n0.0\n1.7\n9.8\n16.70\n31.5\n▇▅▅▃▁\n\n\nmin_rel_humidity\n19\n0.99\n56.63\n18.72\n15.0\n42.0\n56.0\n70.00\n100.0\n▂▇▇▆▂\n\n\nmax_rel_humidity\n22\n0.98\n92.31\n9.40\n47.0\n88.0\n96.0\n100.00\n100.0\n▁▁▁▂▇\n\n\ntotal_precipitation\n554\n0.61\n4.16\n9.75\n0.0\n0.0\n0.0\n3.00\n102.4\n▇▁▁▁▁\n\n\n\n\n\nDrop some un-needed variables:\n\ndaily_climate <- daily_climate %>%\n  select(-station_name, -climate_identifier, -id, -province_code)\n\nProcess the date variable:\n\ndaily_climate <- daily_climate %>%\n  mutate(report_date = as.POSIXct(local_date) %>% as.Date()) %>%\n  # Can drop these now\n  select(-local_date, -local_year, -local_month, -local_day)\n\nThere happens to be some missing days:\n\ntibble(report_date = seq.Date(as.Date(\"2018-05-14\"), as.Date(\"2022-04-22\"),\n                              by = \"days\")) %>%\n  anti_join(daily_climate, by = \"report_date\") %>%\n  pull(report_date)\n\n [1] \"2020-01-02\" \"2020-01-03\" \"2020-01-04\" \"2020-01-05\" \"2020-01-06\"\n [6] \"2021-01-03\" \"2021-01-04\" \"2021-01-05\" \"2021-01-06\" \"2021-01-07\"\n[11] \"2022-01-03\"\n\n\nSeems odd that all of the missing days are in January of different years.\nThere are also some missing temperature values:\n\ndaily_climate %>%\n  filter(\n    is.na(mean_temperature) | is.na(min_temperature) | is.na(max_temperature)\n  ) %>%\n  select(report_date, contains(\"_temperature\")) %>%\n  rmarkdown::paged_table()\n\n\n\n  \n\n\n\nThe report_dates range from 2018 to 2022. The flag values (*_temperature_flag) are all “M”, telling us what we already know: the data is missing.\nFor non-missing values, here is the trend over time:\n\ndaily_climate %>%\n  filter(!is.na(mean_temperature)) %>%\n  ggplot(aes(x = report_date)) +\n  geom_line(aes(y = mean_temperature), color = td_colors$nice$ruby_red)\n\n\n\n\nThe total_precipitation values:\n\ndaily_climate %>%\n  count(total_precipitation, total_precipitation_flag) %>%\n  arrange(desc(is.na(total_precipitation))) %>%\n  rmarkdown::paged_table()\n\n\n\n  \n\n\n\nThere are missing total_precipitation values with NA total_precipitation_flag, which makes me think that the flag variables are not going to be useful/reliable.\nVisualize the non-missing:\n\ndaily_climate %>%\n  filter(!is.na(total_precipitation)) %>%\n  ggplot(aes(x = report_date)) +\n  geom_point(aes(y = total_precipitation), color = td_colors$nice$spanish_blue)\n\n\n\n\nThe snow_on_ground values:\n\ndaily_climate %>%\n  count(snow_on_ground) %>%\n  arrange(desc(is.na(snow_on_ground))) %>%\n  rmarkdown::paged_table()\n\n\n\n  \n\n\n\n\ndaily_climate %>%\n  filter(!is.na(snow_on_ground)) %>%\n  ggplot(aes(x = report_date)) +\n  geom_point(aes(y = snow_on_ground), color = td_colors$nice$spanish_blue)\n\n\n\n\nThe speed_max_gust values (in km/h):\n\ndaily_climate %>%\n  count(speed_max_gust, speed_max_gust_flag) %>%\n  arrange(desc(is.na(speed_max_gust))) %>%\n  rmarkdown::paged_table()\n\n\n\n  \n\n\n\n\ndaily_climate %>%\n  filter(!is.na(speed_max_gust)) %>%\n  ggplot(aes(x = report_date)) +\n  geom_point(aes(y = speed_max_gust), color = td_colors$nice$emerald)"
  },
  {
    "objectID": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html#combining-the-data",
    "href": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html#combining-the-data",
    "title": "Predicting bike ridership: getting the data",
    "section": "Combining the data",
    "text": "Combining the data\nNow I’ll combine the two data sets (joining on the date), only taking the most useful variables from the climate report (temperature, precipitation, wind speed, snow):\n\nbike_counts_climate <- bike_data_daily_counts %>%\n  left_join(\n    daily_climate %>%\n      select(report_date, mean_temperature, total_precipitation,\n             speed_max_gust, snow_on_ground),\n    by = c(\"count_date\" = \"report_date\")\n  )\nglimpse(bike_counts_climate)\n\nRows: 2,840\nColumns: 9\n$ site_name           <chr> \"Dartmouth Harbourfront Greenway\", \"Dartmouth Harb…\n$ installation_date   <date> 2021-07-08, 2021-07-08, 2021-07-08, 2021-07-08, 2…\n$ count_date          <date> 2021-07-08, 2021-07-09, 2021-07-10, 2021-07-11, 2…\n$ n_records           <int> 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48…\n$ n_bikes             <int> 130, 54, 180, 245, 208, 250, 182, 106, 152, 257, 1…\n$ mean_temperature    <dbl> 18.2, 17.6, 21.0, 21.0, 20.6, 18.6, 17.7, 20.2, 20…\n$ total_precipitation <dbl> 0.6, 10.0, 0.4, 0.0, 0.0, 0.0, 0.0, 11.6, 0.2, 0.4…\n$ speed_max_gust      <int> NA, 54, 56, NA, NA, NA, NA, 32, 37, NA, NA, NA, NA…\n$ snow_on_ground      <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\n\nVisualize the missing climate data:\n\nbike_counts_climate %>%\n  distinct(count_date, mean_temperature, total_precipitation,\n           speed_max_gust, snow_on_ground) %>%\n  mutate(across(where(is.numeric), is.na)) %>%\n  pivot_longer(cols = -count_date) %>%\n  ggplot(aes(x = count_date, y = name)) +\n  geom_tile(aes(fill = value)) +\n  labs(y = NULL, x = NULL, fill = \"Missing\") +\n  scale_fill_manual(values = c(td_colors$nice$indigo_blue, \"gray80\")) +\n  scale_x_date(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) +\n  theme(legend.position = \"top\")\n\n\n\n\nQuite a bit of missing data, but we should have enough to make for an interesting analysis. Save the data:\n\nwrite_rds(bike_counts_climate, \"bike-ridership-data.rds\")\n\nIn my next post, I will use this data to develop and evaluate various prediction models."
  },
  {
    "objectID": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html#reproducibility",
    "href": "posts/2022-04-27-predicting-bike-ridership-getting-the-data/predicting-bike-ridership-getting-the-data.html#reproducibility",
    "title": "Predicting bike ridership: getting the data",
    "section": "Reproducibility",
    "text": "Reproducibility\n\n\n\nSession info\n\n\n\n setting  value\n version  R version 4.2.1 (2022-06-23 ucrt)\n os       Windows 10 x64 (build 19044)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Canada.utf8\n ctype    English_Canada.utf8\n tz       America/Curacao\n date     2022-08-07\n pandoc   2.18 @ C:/Program Files/RStudio/bin/quarto/bin/tools/ (via rmarkdown)\n\n\n\n\n  \n\n\n\n\n\n\nGit repository\n\n\n\nLocal:    main C:/Users/tdunn/Documents/tdunn-quarto\nRemote:   main @ origin (https://github.com/taylordunn/tdunn-quarto.git)\nHead:     [53358c7] 2022-08-06: Set fonts and trying out `renv.lock` for reproducibility\n\n\n\nSource code, R environment"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "Reusehttps://creativecommons.org/licenses/by/4.0/CitationBibTeX citation:@online{dunn2022,\n  author = {Taylor Dunn and Harlow Malloc},\n  title = {Post {With} {Code}},\n  date = {2022-07-12},\n  url = {https://tdunn.ca/posts/post-with-code},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nTaylor Dunn, and Harlow Malloc. 2022. “Post With Code.”\nJuly 12, 2022. https://tdunn.ca/posts/post-with-code."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Since this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts.\n\n\n\nReusehttps://creativecommons.org/licenses/by/4.0/CitationBibTeX citation:@online{dunn2022,\n  author = {Taylor Dunn and Tristan O’Malley},\n  title = {Welcome {To} {My} {Blog}},\n  date = {2022-07-09},\n  url = {https://tdunn.ca/posts/welcome},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nTaylor Dunn, and Tristan O’Malley. 2022. “Welcome To My\nBlog.” July 9, 2022. https://tdunn.ca/posts/welcome."
  },
  {
    "objectID": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html",
    "href": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html",
    "title": "Predicting bike ridership: developing a model",
    "section": "",
    "text": "R setup\nlibrary(tidyverse)\nlibrary(gt)\nlibrary(patchwork)\nlibrary(tidymodels)\nlibrary(tictoc)\n\nlibrary(dunnr)\nextrafont::loadfonts(device = \"win\", quiet = TRUE)\ntheme_set(theme_td())\nset_geom_fonts()\nset_palette()"
  },
  {
    "objectID": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#introduction",
    "href": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#introduction",
    "title": "Predicting bike ridership: developing a model",
    "section": "Introduction",
    "text": "Introduction\nIn my last post, I retrieved, explored, and prepared bike counter data from Halifax, Nova Scotia. I also got some historical weather data to go along with it. Here, I will further explore the data, engineer some features, and fit and evaluate many models to predict bike ridership at different sites around the city."
  },
  {
    "objectID": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#exploratory-data-analysis",
    "href": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#exploratory-data-analysis",
    "title": "Predicting bike ridership: developing a model",
    "section": "Exploratory data analysis",
    "text": "Exploratory data analysis\nImport the data:\n\nbike_ridership <- read_rds(\"bike-ridership-data.rds\")\n\n\nglimpse(bike_ridership)\n\nRows: 2,840\nColumns: 9\n$ site_name           <chr> \"Dartmouth Harbourfront Greenway\", \"Dartmouth Harb…\n$ installation_date   <date> 2021-07-08, 2021-07-08, 2021-07-08, 2021-07-08, 2…\n$ count_date          <date> 2021-07-08, 2021-07-09, 2021-07-10, 2021-07-11, 2…\n$ n_records           <int> 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48…\n$ n_bikes             <int> 130, 54, 180, 245, 208, 250, 182, 106, 152, 257, 1…\n$ mean_temperature    <dbl> 18.2, 17.6, 21.0, 21.0, 20.6, 18.6, 17.7, 20.2, 20…\n$ total_precipitation <dbl> 0.6, 10.0, 0.4, 0.0, 0.0, 0.0, 0.0, 11.6, 0.2, 0.4…\n$ speed_max_gust      <int> NA, 54, 56, NA, NA, NA, NA, 32, 37, NA, NA, NA, NA…\n$ snow_on_ground      <int> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n\n\nThis data consists of daily bike counts (n_bikes) over a 24 hour period (count_date) recorded at 5 sites (site_name) around the city. In the original data, counts are recorded every hour which is reflected by the n_records variable:\n\nbike_ridership %>%\n  count(site_name, n_records) %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      site_name\n      n_records\n      n\n    \n  \n  \n    Dartmouth Harbourfront Greenway\n8\n1\n    Dartmouth Harbourfront Greenway\n48\n291\n    Hollis St\n4\n1\n    Hollis St\n24\n656\n    South Park St\n8\n1\n    South Park St\n48\n884\n    Vernon St\n8\n1\n    Vernon St\n48\n502\n    Windsor St\n8\n1\n    Windsor St\n48\n502\n  \n  \n  \n\n\n\n\nAll except the Hollis St site have two channels (northbound and southbound), which is why n_records = 48. The entries with fewer n_records reflect the time of day that the data was extracted:\n\nbike_ridership %>%\n  filter(n_records < 24) %>%\n  select(site_name, count_date, n_records) %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      site_name\n      count_date\n      n_records\n    \n  \n  \n    Dartmouth Harbourfront Greenway\n2022-04-25\n8\n    Hollis St\n2022-04-25\n4\n    South Park St\n2022-04-25\n8\n    Vernon St\n2022-04-25\n8\n    Windsor St\n2022-04-25\n8\n  \n  \n  \n\n\n\n\nFor this analysis, I will exclude this incomplete day:\n\nbike_ridership <- bike_ridership %>% filter(n_records > 8)\n\nThe date ranges for each site:\n\nbike_ridership %>%\n  group_by(site_name) %>%\n  summarise(\n    min_date = min(count_date), max_date = max(count_date),\n    n_days = n(), .groups = \"drop\"\n  ) %>%\n  mutate(\n    site_name = fct_reorder(site_name, min_date),\n    n_days_label = ifelse(site_name == levels(site_name)[1],\n                          str_c(\"n_days = \", n_days), n_days),\n    midpoint_date = min_date + n_days / 2\n  ) %>%\n  ggplot(aes(y = site_name, color = site_name)) +\n  geom_linerange(aes(xmin = min_date, xmax = max_date)) +\n  geom_point(aes(x = min_date)) +\n  geom_point(aes(x = max_date)) +\n  geom_text(aes(label = n_days_label, x = midpoint_date), vjust = -0.5) +\n  scale_y_discrete(labels = ~ str_wrap(., width = 15)) +\n  labs(y = NULL, x = \"min_date -> max_date\") +\n  theme(legend.position = \"none\")\n\n\n\n\nBefore any more EDA, I’ll split the data into training and testing sets (and only look at the training data going forward). For time series data, there is the rsample::initial_time_split() function, which I’ll use to make a 70-30 split:\n\n# Need to order by time to properly use time split\nbike_ridership <- bike_ridership %>% arrange(count_date, site_name)\n\nbike_split <- initial_time_split(bike_ridership, prop = 0.7)\n\nbike_train <- training(bike_split)\nbike_test <- testing(bike_split)\n\nbind_rows(\n  train = bike_train, test = bike_test, .id = \"data_set\"\n) %>%\n  group_by(data_set, site_name) %>%\n  summarise(\n    min_date = min(count_date), max_date = max(count_date),\n    n_days = n(), midpoint_date = min_date + n_days / 2,\n    .groups = \"drop\"\n  ) %>%\n  ggplot(aes(y = fct_reorder(site_name, min_date), color = data_set)) +\n  geom_linerange(aes(xmin = min_date, xmax = max_date),\n                 position = position_dodge(0.2)) +\n  geom_point(aes(x = min_date), position = position_dodge(0.2)) +\n  geom_point(aes(x = max_date), position = position_dodge(0.2)) +\n  geom_text(aes(label = n_days, x = midpoint_date), vjust = -0.5,\n            position = position_dodge(0.2), show.legend = FALSE) +\n  labs(x = \"date range\", y = NULL, color = NULL)\n\n\n\n\nIt might make more sense to stratify by site_name so that there is a 70-30 split in each site.1 For now, I’m using a simpler approach to split into the first 70% and 30% of the data.\nFor each site, the distribution of daily n_bikes:\n\nbike_train %>%\n  ggplot(aes(x = n_bikes, fill = site_name)) +\n  geom_histogram(bins = 30) +\n  facet_wrap(~ str_trunc(site_name, 25)) +\n  theme(legend.position = \"none\")\n\n\n\n\nThe South Park St site appears bimodal, which I noted in part 1 was likely due to the addition of protected bike lanes in 2021. This can be seen more clearly in the trend over time:\n\nbike_train %>%\n  ggplot(aes(x = count_date, y = n_bikes, color = site_name)) +\n  geom_line() +\n  facet_wrap(~ site_name, ncol = 1) +\n  theme(legend.position = \"none\")\n\n\n\n\nAs you would expect for data in the same city, bike counters between sites are very highly correlated, which I can visualize:\n\nbike_train %>%\n  transmute(count_date, n_bikes1 = n_bikes,\n            site_name1 = factor(str_trunc(site_name, 10))) %>%\n  left_join(., rename(., n_bikes2 = n_bikes1, site_name2 = site_name1),\n            by = \"count_date\") %>%\n  filter(as.numeric(site_name1) < as.numeric(site_name2)) %>%\n  ggplot(aes(x = n_bikes1, y = n_bikes2)) +\n  geom_point(aes(color = site_name1), alpha = 0.3) +\n  facet_grid(site_name2 ~ site_name1) +\n  theme(legend.position = \"none\") +\n  dunnr::add_facet_borders()\n\n\n\n\nThe day of the week effect looks important:\n\nbike_train %>%\n  mutate(day_of_week = lubridate::wday(count_date, label = TRUE)) %>%\n  ggplot(aes(x = day_of_week, y = n_bikes)) +\n  geom_jitter(aes(color = site_name), height = 0, width = 0.2, alpha = 0.3) +\n  stat_summary(fun = \"mean\", geom = \"point\") +\n  facet_wrap(~ str_trunc(site_name, 30)) +\n  theme(legend.position = \"none\") +\n  dunnr::add_facet_borders()\n\n\n\n\nAnother thing to consider is holidays. I can get Canadian holidays with the timeDate package (this is how recipes::step_holiday() works):\n\nlibrary(timeDate)\ncanada_holidays <-\n  timeDate::listHolidays(\n    pattern = \"^CA|^Christmas|^NewYears|Easter[Sun|Mon]|^GoodFriday|^CaRem\"\n  )\ncanada_holidays\n\n [1] \"CACanadaDay\"              \"CACivicProvincialHoliday\"\n [3] \"CALabourDay\"              \"CaRemembranceDay\"        \n [5] \"CAThanksgivingDay\"        \"CAVictoriaDay\"           \n [7] \"ChristmasDay\"             \"ChristmasEve\"            \n [9] \"EasterMonday\"             \"EasterSunday\"            \n[11] \"GoodFriday\"               \"NewYearsDay\"             \n\n\nThen get the dates for each across the years in the bike data:\n\ncanada_holiday_dates <- tibble(holiday = canada_holidays) %>%\n  crossing(year = 2019:2022) %>%\n  mutate(\n    holiday_date = map2(\n      year, holiday,\n      ~ as.Date(timeDate::holiday(.x, .y)@Data)\n    )\n  ) %>%\n  unnest(holiday_date)\n\ncanada_holiday_dates %>%\n  select(holiday, holiday_date) %>%\n  rmarkdown::paged_table()\n\n\n\n  \n\n\n\nOnly day I can think is missing from this list is Family Day (Heritage Day in Nova Scotia) which is the third Monday in February. Visualize the effect of these holidays on bike ridership by plotting n_bikes in a 2 week window around the holidays (showing just the South Park St site for this plot):\n\ncanada_holiday_dates %>%\n  filter(holiday_date %in% unique(bike_train$count_date)) %>%\n  mutate(\n    date_window = map(holiday_date, ~ seq.Date(.x - 7, .x + 7, by = \"1 day\"))\n  ) %>%\n  unnest(date_window) %>%\n  left_join(\n    bike_train, by = c(\"date_window\" = \"count_date\")\n  ) %>%\n  mutate(is_holiday = holiday_date == date_window) %>%\n  group_by(holiday) %>%\n  mutate(day_from_holiday = as.numeric(holiday_date - date_window)) %>%\n  ungroup() %>%\n  filter(site_name == \"South Park St\") %>%\n  ggplot(aes(x = day_from_holiday, y = n_bikes,\n             group = factor(year))) +\n  geom_line() +\n  geom_vline(xintercept = 0, lty = 2) +\n  geom_point(aes(color = factor(year))) +\n  facet_wrap(~ holiday) +\n  labs(color = \"year\") +\n  dunnr::add_facet_borders() +\n  theme(legend.position = \"top\")\n\n\n\n\nThe only holidays with a clear drop in ridership are Labour Day and the Civic Holiday (called Natal Day in NS) in 2021. Victoria Day seems to have the opposite effect. The Good Friday, Easter Sunday and Easter Monday holidays are obviously overlapping, and the n_bikes trend is a bit of a mess, but I can see an indication to the left of Good Friday that there may be a drop in ridership going into that weekend.\nOne thing to note is that the first, middle and last points correspond to the same day of the week, and the middle point in this set is usually lower than those two point, so holidays may be useful features in conjunction with day of the week.\nThe weather variables have varying levels of completeness:\n\n# Separate out the weather data\nweather_data <- bike_train %>%\n  distinct(count_date, mean_temperature, total_precipitation,\n           speed_max_gust, snow_on_ground)\n\nweather_data %>%\n  mutate(across(where(is.numeric), is.na)) %>%\n  pivot_longer(cols = -count_date) %>%\n  ggplot(aes(x = count_date, y = name)) +\n  geom_tile(aes(fill = value)) +\n  labs(y = NULL, x = NULL, fill = \"Missing\") +\n  scale_fill_manual(values = c(td_colors$nice$indigo_blue, \"gray80\")) +\n  scale_x_date(expand = c(0, 0)) +\n  scale_y_discrete(expand = c(0, 0)) +\n  theme(legend.position = \"top\")\n\n\n\n\nThe distributions:\n\nweather_data %>%\n  pivot_longer(cols = -count_date) %>%\n  filter(!is.na(value)) %>%\n  ggplot(aes(x = value, fill = name)) +\n  geom_histogram(bins = 20) +\n  scale_y_continuous(expand = c(0, 0)) +\n  facet_wrap(~ name, nrow = 1, scales = \"free\") +\n  theme(legend.position = \"none\")\n\n\n\n\nFor non-missing cases, plot the pairwise relationships:\n\nweather_data %>%\n  pivot_longer(cols = -count_date, names_to = \"var1\", values_to = \"val1\") %>%\n  mutate(var1 = factor(var1)) %>%\n  left_join(., rename(., var2 = var1, val2 = val1),\n            by = \"count_date\") %>%\n  filter(!is.na(val1), !is.na(val2),\n         # Use numeric factor labels to remove duplicates\n         as.numeric(var1) < as.numeric(var2)) %>%\n  ggplot(aes(x = val1, y = val2, color = var1)) +\n  geom_point(alpha = 0.5) +\n  facet_grid(var2 ~ var1, scales = \"free\") +\n  theme(legend.position = \"none\") +\n  dunnr::add_facet_borders()\n\n\n\n\nThe clearest relationship to me is unsurprising: increasing mean_temperature is associated with decreasing snow_on_ground (top left plot).\nVisualize relationships with n_bikes:\n\nbike_train %>%\n  pivot_longer(\n    cols = c(mean_temperature, total_precipitation,\n             speed_max_gust, snow_on_ground),\n    names_to = \"var\", values_to = \"val\"\n  ) %>%\n  filter(!is.na(val)) %>%\n  ggplot(aes(x = val, y = n_bikes)) +\n  geom_point(aes(color = str_trunc(site_name, 15)), alpha = 0.4) +\n  facet_wrap(~ var, nrow = 2, scales = \"free_x\") +\n  dunnr::add_facet_borders() +\n  labs(x = NULL, color = NULL) +\n  theme(legend.position = \"bottom\")\n\n\n\n\nAll of the weather variables seem to be have a relationship with n_bikes. In terms of predictive value, mean_temperature looks like it might be the most useful, and speed_max_gust the least."
  },
  {
    "objectID": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#feature-engineering",
    "href": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#feature-engineering",
    "title": "Predicting bike ridership: developing a model",
    "section": "Feature engineering",
    "text": "Feature engineering\nFrom my EDA, I decided I want try including all 4 weather variables to predict bike ridership. This will require imputation of missing values for all 4, which I’ll attempt here.\nAdd some more time variables for working with the weather_data:\n\nweather_data <- weather_data %>%\n  mutate(count_year = lubridate::year(count_date),\n         # Day number relative to earliest date\n         count_day = as.numeric(count_date - min(count_date)),\n         # Day of the year, from 1 to 365\n         count_yday = lubridate::yday(count_date))\n\n\nTemperature\nThe mean_temperature variable is missing 3% of values. Visualize the trend over time:\n\np1 <- weather_data %>%\n  filter(!is.na(mean_temperature)) %>%\n  ggplot(aes(x = count_date, y = mean_temperature)) +\n  geom_line(aes(color = factor(count_year))) +\n  scale_color_viridis_d(\"year\") +\n  scale_x_date(\"date\", date_breaks = \"1 year\")\np2 <- weather_data %>%\n  filter(!is.na(mean_temperature)) %>%\n  ggplot(aes(x = count_yday, y = mean_temperature)) +\n  geom_line(aes(color = factor(count_year))) +\n  scale_color_viridis_d(\"year\") +\n  scale_x_continuous(\"day of year\", breaks = c(0, 90, 180, 270, 365)) +\n  labs(y = NULL)\np1 + p2 +\n  plot_layout(guides = \"collect\") &\n  theme(legend.position = \"top\")\n\n\n\n\nThe cyclic nature makes it a good candidate for smoothing splines. As a starting point, try a natural spline with 5 knots on the count_yday variable:\n\nlibrary(splines)\nlm_temperature <- \n  lm(mean_temperature ~ ns(count_yday, knots = 5),\n      data = filter(weather_data, !is.na(mean_temperature)))\n\np1 +\n  geom_line(\n    data = augment(lm_temperature, newdata = weather_data),\n    aes(y = .fitted), size = 1\n  ) +\n  theme(legend.position = \"top\")\n\n\n\n\nWe can obviously do a lot better, especially at the yearly boundaries. I’ll fit the data using a generalized additive model (GAM) with the mgcv package.2 For the count_yday variable (ranges from 1-365), I’ll make sure that there is no discontinuity between year by using a cyclic spline (bs = \"cc\"). I’ll also include a smoothing term of count_day which will capture the trend across years.\n\nlibrary(mgcv)\n\ngam_temperature <-\n  gam(mean_temperature ~ s(count_yday, bs = \"cc\", k = 12) + s(count_day),\n      data = filter(weather_data, !is.na(mean_temperature)))\nplot(gam_temperature, pages = 1, shade = TRUE)\n\n\n\n\nThe left plot shows the seasonal trend within a year (note the lines would connect at count_yday = 1 and 365), and the right plot shows the increase in average temperature throughout time (across years) after accounting for the seasonal effect. Overlay the fit:\n\np1 +\n  geom_line(\n    data = augment(gam_temperature, newdata = weather_data),\n    aes(y = .fitted), size = 1\n  ) +\n  theme(legend.position = \"top\")\n\n\n\n\nI’m pretty happy with that. I’ll use predictions from this GAM to impute missing daily temperatures.\n\n\nPrecipitation and snow\nThe total_precipitation variable is missing 36% of values; 76% for snow_on_ground.\nThe total_precipitation distribution:\n\np1 <- weather_data %>%\n  mutate(total_precipitation = replace_na(total_precipitation, -5)) %>%\n  ggplot(aes(x = count_date, y = total_precipitation)) +\n  geom_point(alpha = 0.5) +\n  scale_y_continuous(breaks = c(-5, 0, 20, 40, 60),\n                     labels = c(\"missing\", 0, 20, 40, 60))\np1\n\n\n\n\nThis pattern of missing data during winter months makes me think that the total_precipitation is actually total rainfall, i.e. snowfall is not counted. I’m going to impute the missing values with 0 during pre-processing, which is admittedly a poor approximation of the truth.\nThe snow_on_ground distribution:\n\np2 <- weather_data %>%\n  mutate(snow_on_ground = replace_na(snow_on_ground, -2)) %>%\n  ggplot(aes(x = count_date, y = snow_on_ground)) +\n  geom_point(alpha = 0.5) +\n  scale_y_continuous(breaks = c(-2, 0, 10, 20),\n                     labels = c(\"missing\", 0, 10, 20))\np2\n\n\n\n\nI’ll also impute zero for missing snow_on_ground, which I’m a lot more confident doing here because most of the missing values occur during non-winter months. A more careful approach might involve imputing 0 during non-winter months that I’m certain would have no snow on the ground, then modeling the winter months with something like a zero-inflated Poisson model.\n\n\nWind speed\nThe speed_max_gust variable is the daily maximum wind speed in km/h, and has 41% missing values.\n\nmean_speed <- mean(weather_data$speed_max_gust, na.rm = TRUE)\n\nweather_data %>%\n  mutate(\n    speed_max_gust = replace_na(speed_max_gust, 20)\n  ) %>%\n  ggplot(aes(x = count_date, y = speed_max_gust)) +\n  geom_line(data = . %>% filter(speed_max_gust > 20)) +\n  geom_smooth(data = . %>% filter(speed_max_gust > 20),\n              method = \"loess\", formula = \"y ~ x\",\n              color = td_colors$nice$spanish_blue) +\n  geom_hline(yintercept = mean_speed,\n             color = td_colors$nice$opera_mauve, size = 1, lty = 2) +\n  geom_jitter(data = . %>% filter(speed_max_gust == 20),\n              width = 0, alpha = 0.5) +\n  scale_y_continuous(breaks = c(mean_speed, 20, 40, 60, 80),\n                     labels = c(\"mean_speed\", \"missing\", 40, 60, 80))\n\n\n\n\nRelative to the noise, the time trends are pretty minor, and the missing data looks to be missing mostly at random. I’ll just impute using the mean speed.\n\n\nLagged counts\nAs a time series data set, it would be careless to not account for past data when predicting future data, so I’ll include lagged n_bikes values. Investigate the correlation in n_bikes for values lagged by 1, 2 and 3 days, and by 1 and 2 weeks (because they are the same day of the week):\n\nbike_train_lag <- bike_train %>%\n  arrange(site_name, count_date) %>%\n  group_by(site_name) %>%\n  mutate(\n    n_bikes_lag_1 = lag(n_bikes, 1),\n    n_bikes_lag_2 = lag(n_bikes, 2),\n    n_bikes_lag_3 = lag(n_bikes, 3),\n    n_bikes_lag_7 = lag(n_bikes, 7),\n    n_bikes_lag_14 = lag(n_bikes, 14)\n  )\nbike_train_lag %>%\n  select(site_name, count_date, starts_with(\"n_bikes\")) %>%\n  pivot_longer(cols = matches(\"n_bikes_lag\"),\n               names_to = \"lag_days\", values_to = \"n_bikes_lag\") %>%\n  filter(!is.na(n_bikes_lag)) %>%\n  mutate(lag_days = str_extract(lag_days, \"\\\\d+\") %>% as.integer()) %>%\n  group_by(site_name, lag_days) %>%\n  mutate(corr_coef = cor(n_bikes, n_bikes_lag)) %>%\n  ggplot(aes(x = n_bikes_lag, y = n_bikes, color = site_name)) +\n  geom_point(alpha = 0.2) +\n  geom_label(data = . %>% distinct(n_bikes_lag, site_name, corr_coef),\n             aes(label = round(corr_coef, 2), x = 500, y = 200)) +\n  geom_abline(slope = 1) +\n  facet_grid(str_trunc(site_name, 8) ~ factor(lag_days)) +\n  dunnr::add_facet_borders() +\n  theme(legend.position = \"none\")\n\n\n\n\nThe 7- and 14-day lagged values are correlated just as strongly (in some cases stronger) than the other options. This is great news because I only want to include a single lag variable, and using the 14th day lag means I can forecast 14 days ahead.\nIn order to use 14-day lag in a tidymodels workflow, I need to add it to the data myself. The step_lag() function won’t allow the outcome n_bikes to be lagged, because any new data won’t have an n_bikes variable to use. See the warning in this section of the Tidy Modeling with R book. Add the n_bikes_lag_14 predictor, and exclude any values without it:\n\nbike_ridership <- bike_ridership %>%\n  group_by(site_name) %>%\n  mutate(n_bikes_lag_14 = lag(n_bikes, 14)) %>%\n  ungroup() %>%\n  filter(!is.na(n_bikes_lag_14))\n\nWhile I’m at it, I’ll impute the missing mean_temperature values with the seasonal GAM.\n\nbike_ridership <- bike_ridership %>%\n  mutate(\n    count_day = as.numeric(count_date - min(count_date)),\n    count_yday = lubridate::yday(count_date),\n  ) %>%\n  bind_cols(pred = predict(gam_temperature, newdata = .)) %>%\n  mutate(\n    mean_temperature = ifelse(is.na(mean_temperature), pred,\n                              mean_temperature)\n  ) %>%\n  select(-count_day, -count_yday, -pred)\n\nThis means I’ll have to re-split the data into training and testing (initial_time_split() isn’t random, so doesn’t require setting the seed):\n\nbike_ridership <- bike_ridership %>% arrange(count_date, site_name)\n\nbike_split <- initial_time_split(bike_ridership, prop = 0.7)\n\nbike_train <- training(bike_split)\nbike_test <- testing(bike_split)"
  },
  {
    "objectID": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#modeling",
    "href": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#modeling",
    "title": "Predicting bike ridership: developing a model",
    "section": "Modeling",
    "text": "Modeling\nRegister parallel computing:\n\nn_cores <- parallel::detectCores(logical = FALSE)\nlibrary(doParallel)\ncl <- makePSOCKcluster(n_cores - 1)\nregisterDoParallel(cl)\n# This extra step makes sure the parallel workers have access to the\n#  `tidyr::replace_na()` function during pre-processing, which I use later on\n# See this issue: https://github.com/tidymodels/tune/issues/364\nparallel::clusterExport(cl, c(\"replace_na\"))\n\n\nResampling and metrics\nFor re-sampling, I will use sliding_period() to break up the data into 14 months of data (chosen to give 10 resamples) for analysis and 1 month for assessment:\n\nbike_resamples <-\n  sliding_period(bike_train, index = count_date,\n                 period = \"month\", lookback = 12, assess_stop = 2)\n\nVisualize the resamples:\n\nbind_rows(\n  analysis_set = map_dfr(bike_resamples$splits, analysis, .id = \"i\"),\n  assessment_set = map_dfr(bike_resamples$splits, assessment, .id = \"i\"),\n  .id = \"data_set\"\n) %>%\n  mutate(i = as.integer(i)) %>%\n  group_by(i, data_set) %>%\n  summarise(\n    min_date = min(count_date), max_date = max(count_date),\n    n_days = n(), midpoint_date = min_date + n_days / 2,\n    .groups = \"drop\"\n  ) %>%\n  ggplot(aes(y = factor(i), color = data_set)) +\n  geom_linerange(aes(xmin = min_date, xmax = max_date),\n                 position = position_dodge(0.3)) +\n  geom_point(aes(x = min_date), position = position_dodge(0.3)) +\n  geom_point(aes(x = max_date), position = position_dodge(0.3)) +\n  labs(x = \"date range\", y = NULL, color = NULL)\n\n\n\n\nI’ll define a set of metrics to use here as well:\n\nbike_metrics <- metric_set(rmse, rsq, mase, poisson_log_loss)\n\nThe Poisson log loss is a new one to me, that was recently added to yardstick. I’ll include it just for kicks, but I will choose my final model with mase, the mean absolute scaled error, which was introduced by Hyndman and Koehler (Hyndman and Koehler 2006). The MASE involves dividing the absolute forecast error (\\(|y_i - \\hat{y}_i|\\)) by absolute naive forecast error (which involves predicting with the last observed value). The main advantage of this is that it is scale invariant. Mean absolute percentage error (MAPE) is the typical scale-invariant choice in regression problems, but the MASE avoids dividing by n_bikes = 0 (of which there are about 20 in this data set). It also has a straightforward interpretation: values greater than one indicate a worse forecast than the naive method, and values less indicate better.\n\n\nGeneralized linear models\nThe first models I will try are simple linear regression and Poisson regression, but I will test out a few different pre-processing/feature combinations. I would prefer to use negative binomial regression instead of Poisson to account for overdispersion (see aside), but it hasn’t been implemented in parsnip yet.\n\nlm_spec <- linear_reg(engine = \"lm\")\nlibrary(poissonreg) # This wrapper package is required to use `poisson_reg()`\npoisson_spec <- poisson_reg(engine = \"glm\")\n\n\n\nOver-dispersion in n_bikes (variance much higher than the mean):\n\nbike_train %>%\n  group_by(site_name) %>%\n  summarise(mean_n_bikes = mean(n_bikes), var_n_bikes = var(n_bikes))\n\n# A tibble: 5 × 3\n  site_name                       mean_n_bikes var_n_bikes\n  <chr>                                  <dbl>       <dbl>\n1 Dartmouth Harbourfront Greenway        145.        3121.\n2 Hollis St                               77.0       2180.\n3 South Park St                          174.       26594.\n4 Vernon St                              212.       18080.\n5 Windsor St                              96.3       3413.\n\n\nFor my base pre-processing, I’ll include just site_name and n_bikes_lag_14:\n\nglm_recipe <-\n  recipe(n_bikes ~ count_date + site_name + n_bikes_lag_14,\n         data = bike_train) %>%\n  add_role(count_date, new_role = \"date_variable\") %>%\n  step_novel(all_nominal_predictors()) %>%\n  step_dummy(all_nominal_predictors()) %>%\n  step_zv(all_predictors())\n\nThe first extension of this recipe will include date variables. I’ll add day of week as categorical, day of year as numerical (and tune a natural spline function), year as numerical and Canadian holidays as categorical.\n\nglm_recipe_date <-\n  recipe(n_bikes ~ count_date + site_name + n_bikes_lag_14,\n         data = bike_train) %>%\n  add_role(count_date, new_role = \"date_variable\") %>%\n  step_date(count_date, features = c(\"dow\", \"doy\", \"year\"),\n            label = TRUE, ordinal = FALSE) %>%\n  step_ns(count_date_doy, deg_free = tune()) %>%\n  step_holiday(count_date, holidays = canada_holidays) %>%\n  step_novel(all_nominal_predictors()) %>%\n  step_dummy(all_nominal_predictors()) %>%\n  step_zv(all_predictors())\n\nI’ll consider the weather variables, with the imputations discussed in the feature engineering section, separately:\n\nglm_recipe_weather <-\n  recipe(n_bikes ~ count_date + site_name + n_bikes_lag_14 + mean_temperature +\n           total_precipitation + speed_max_gust + snow_on_ground,\n         data = bike_train) %>%\n  add_role(count_date, new_role = \"date_variable\") %>%\n  step_impute_mean(speed_max_gust) %>%\n  # Impute these missing values with zero\n  step_mutate_at(c(total_precipitation, snow_on_ground),\n                 fn = ~ replace_na(., 0)) %>%\n  step_novel(all_nominal_predictors()) %>%\n  step_dummy(all_nominal_predictors()) %>%\n  step_zv(all_predictors())\n\nAnd lastly, all the features together:\n\nglm_recipe_date_weather <-\n  recipe(n_bikes ~ count_date + site_name + n_bikes_lag_14 + mean_temperature +\n           total_precipitation + speed_max_gust + snow_on_ground,\n         data = bike_train) %>%\n  add_role(count_date, new_role = \"date_variable\") %>%\n  step_date(count_date, features = c(\"dow\", \"doy\", \"year\"),\n            label = TRUE, ordinal = FALSE) %>%\n  step_ns(count_date_doy, deg_free = tune()) %>%\n  step_holiday(count_date, holidays = canada_holidays) %>%\n  step_impute_mean(speed_max_gust) %>%\n  step_mutate_at(c(total_precipitation, snow_on_ground),\n                 fn = ~ replace_na(., 0)) %>%\n  step_novel(all_nominal_predictors()) %>%\n  step_dummy(all_nominal_predictors()) %>%\n  step_zv(all_predictors())\n\nPut these pre-processing recipes and the model specifications into a workflow_set():\n\nglm_wf_set <- workflow_set(\n  preproc = list(base = glm_recipe,\n                 date = glm_recipe_date, weather = glm_recipe_weather,\n                 date_weather = glm_recipe_date_weather),\n  models = list(linear_reg = lm_spec, poisson_reg = poisson_spec),\n  cross = TRUE\n)\n\nNow fit the resamples using each combination of model specification and pre-processing recipe:\n\ntic()\nglm_wf_set_res <- workflow_map(\n  glm_wf_set,\n  \"tune_grid\",\n  # I'll try just a few `deg_free` in the spline term\n  grid = grid_regular(deg_free(range = c(4, 7)), levels = 4),\n  resamples = bike_resamples, metrics = bike_metrics\n)\ntoc()\n\n39.89 sec elapsed\n\n\nFor plotting the results this set of workflows, I’ll use a custom plotting function with rank_results():\n\nplot_wf_set_metrics <- function(wf_set_res, rank_metric = \"mase\") {\n  rank_results(wf_set_res, rank_metric = rank_metric) %>%\n    mutate(preproc = str_remove(wflow_id, paste0(\"_\", model))) %>%\n    ggplot(aes(x = rank, y = mean, color = model, shape = preproc)) +\n    geom_point(size = 2) +\n    geom_errorbar(aes(ymin = mean - std_err, ymax = mean + std_err),\n                  width = 0.2) +\n    facet_wrap(~ .metric, scales = \"free_y\")\n  \n}\nplot_wf_set_metrics(glm_wf_set_res)\n\n\n\n\n\n\nI’m using my own function because the workflowsets::autoplot() function doesn’t distinguish preprocessor recipes using the names provided to the preproc argument – everything just gets the name “recipe”:\n\nrank_results(glm_wf_set_res) %>%\n  distinct(wflow_id, model, preprocessor)\n\n# A tibble: 8 × 3\n  wflow_id                 preprocessor model      \n  <chr>                    <chr>        <chr>      \n1 date_weather_poisson_reg recipe       poisson_reg\n2 date_weather_linear_reg  recipe       linear_reg \n3 weather_linear_reg       recipe       linear_reg \n4 date_linear_reg          recipe       linear_reg \n5 base_linear_reg          recipe       linear_reg \n6 date_poisson_reg         recipe       poisson_reg\n7 weather_poisson_reg      recipe       poisson_reg\n8 base_poisson_reg         recipe       poisson_reg\n\n\nMy function extracts the recipe name from wflow_id.\nAcross the board, the model will all the features (date and weather predictors; indicated by the square symbols) are best, and Poisson regression slightly outperforms linear. Here are the models ranked by MASE:3\n\nrank_results(glm_wf_set_res, select_best = TRUE, rank_metric = \"mase\") %>%\n  filter(.metric == \"mase\") %>%\n  select(rank, wflow_id, .config, mase = mean, std_err) %>%\n  gt() %>%\n  fmt_number(columns = c(mase, std_err), decimals = 3)\n\n\n\n\n\n  \n  \n    \n      rank\n      wflow_id\n      .config\n      mase\n      std_err\n    \n  \n  \n    1\ndate_weather_poisson_reg\nPreprocessor3_Model1\n0.547\n0.056\n    2\ndate_weather_linear_reg\nPreprocessor3_Model1\n0.577\n0.075\n    3\ndate_linear_reg\nPreprocessor2_Model1\n0.604\n0.052\n    4\nweather_linear_reg\nPreprocessor1_Model1\n0.622\n0.067\n    5\ndate_poisson_reg\nPreprocessor2_Model1\n0.626\n0.064\n    6\nbase_linear_reg\nPreprocessor1_Model1\n0.635\n0.055\n    7\nweather_poisson_reg\nPreprocessor1_Model1\n0.670\n0.080\n    8\nbase_poisson_reg\nPreprocessor1_Model1\n0.760\n0.055\n  \n  \n  \n\n\n\n\nSo our best workflow has the id date_weather_poisson_reg4 with the .config “Preprocessor3_Model1” which refers to a specific spline degree from our tuning of the count_date_doy feature. I can check out the results of the tuning with autoplot():\n\nautoplot(glm_wf_set_res, id = \"date_weather_poisson_reg\") +\n  facet_wrap(~ .metric, nrow = 2, scales = \"free_y\")\n\n\n\n\nThe polynomial of degree 6 did best by MASE, which I’ll use to finalize the workflow and fit to the full training set:\n\nglm_poisson_workflow <- finalize_workflow(\n  extract_workflow(glm_wf_set_res, \"date_weather_poisson_reg\"),\n  extract_workflow_set_result(glm_wf_set_res, \"date_weather_poisson_reg\") %>%\n    select_best(metric = \"mase\")\n)\nglm_poisson_fit <- glm_poisson_workflow %>% fit(bike_train)\n\n\nModel interpretation\nAn advantage of using a generalized linear model is that they are easy to interpret. A simple way to estimate variable important in a GLM is to look at the absolute value of the \\(t\\)-statistic (statistic in the below table) – here are the top 5:\n\npoisson_coefs <- tidy(glm_poisson_fit) %>%\n  arrange(desc(abs(statistic))) %>%\n  mutate(estimate = signif(estimate, 3), std.error = signif(estimate, 2),\n         statistic = round(statistic, 1), p.value = scales::pvalue(p.value))\nhead(poisson_coefs, 5) %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      term\n      estimate\n      std.error\n      statistic\n      p.value\n    \n  \n  \n    total_precipitation\n-0.0384\n-0.038\n-84.6\n<0.001\n    site_name_South.Park.St\n0.6890\n0.690\n68.6\n<0.001\n    site_name_Vernon.St\n0.5490\n0.550\n57.8\n<0.001\n    mean_temperature\n0.0365\n0.036\n53.3\n<0.001\n    n_bikes_lag_14\n0.0010\n0.001\n48.2\n<0.001\n  \n  \n  \n\n\n\n\nA couple of the weather variables are among the most influential in predicting n_bikes. Here are all the weather coefficients:\n\npoisson_coefs %>%\n  filter(str_detect(term, \"temperature|precip|max_gust|snow\")) %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      term\n      estimate\n      std.error\n      statistic\n      p.value\n    \n  \n  \n    total_precipitation\n-0.03840\n-0.0380\n-84.6\n<0.001\n    mean_temperature\n0.03650\n0.0360\n53.3\n<0.001\n    snow_on_ground\n-0.05360\n-0.0540\n-28.9\n<0.001\n    speed_max_gust\n-0.00735\n-0.0074\n-19.6\n<0.001\n  \n  \n  \n\n\n\n\nSince this is a Poisson model, the link function (non-linear relationship between the outcome and the predictors) is the logarithm:\n\\[\n\\begin{align}\n\\log{n}_{\\text{bikes}} &= \\beta_0 + \\beta_1 x_1 + \\dots + \\beta_p x_p \\\\\nn_{\\text{bikes}} &= \\text{exp}(\\beta_0 + \\beta_1 x_1 + \\dots + \\beta_p x_p) \\\\\n&= \\text{exp}(\\beta_0) \\text{exp}(\\beta_1 x_1) \\dots \\text{exp}(\\beta_p x_p) \\\\\n\\end{align}\n\\]\nSo the coefficients are interpreted as: for every one unit increase in \\(x_i\\), the expected value of \\(n_{\\text{bikes}}\\) changes by multiplicative factor of \\(\\text{exp}(\\beta_i)\\), holding all other predictors constant. Here are some plain-language interpretations of the weather coefficients:\n\nFor every 5°C increase in daily average temperature (mean_temperature), the expected value of n_bikes increases by 120%.\nFor every 10mm increase in daily rain (total_precipitation), the expected value of n_bikes decreases by 68%.\nFor every 10km/h increase in maximum wind speed (speed_max_gust), the expected value of n_bikes decreases by 93%.\nFor every 5cm of snow (snow_on_ground), the expected value of n_bikes decreases by 77%.\n\nA more thorough and formal analysis of these types of relationships should involve exploration of marginal effects (with a package like marginaleffects for example), but I’ll move on to other models.\n\n\n\nTree-based methods\nFor tree-based methods, I’ll use similar pre-processing as with GLM, except I won’t use a spline term (trees partition the feature space to capture non-linearity):\n\ntrees_recipe <-\n  recipe(n_bikes ~ count_date + site_name + n_bikes_lag_14 + mean_temperature +\n           total_precipitation + speed_max_gust + snow_on_ground,\n         data = bike_train) %>%\n  update_role(count_date, new_role = \"date_variable\") %>%\n  step_date(count_date, features = c(\"dow\", \"doy\", \"year\"),\n            label = TRUE, ordinal = FALSE) %>%\n  step_holiday(count_date, holidays = canada_holidays) %>%\n  step_novel(all_nominal_predictors()) %>%\n  step_impute_mean(speed_max_gust) %>%\n  step_mutate_at(c(total_precipitation, snow_on_ground),\n                 fn = ~ replace_na(., 0)) %>%\n  step_zv(all_predictors())\n\n# XGBoost requires dummy variables\ntrees_recipe_dummy <- trees_recipe %>%\n  step_dummy(all_nominal_predictors())\n\nI’ll try a decision tree, a random forest, and an XGBoost model, each with hyperparameters indicated for tuning:\n\ndecision_spec <-\n  decision_tree(cost_complexity = tune(), tree_depth = tune(),\n                min_n = tune()) %>%\n  set_engine(\"rpart\") %>%\n  set_mode(\"regression\")\n\nrf_spec <- rand_forest(mtry = tune(), min_n = tune(), trees = 1000) %>%\n  # Setting the `importance` parameter now lets me use `vip` later\n  set_engine(\"ranger\", importance = \"permutation\") %>%\n  set_mode(\"regression\")\n\nxgb_spec <- boost_tree(\n  mtry = tune(), trees = tune(), min_n = tune(),\n  tree_depth = tune(), learn_rate = tune()\n) %>%\n  set_engine(\"xgboost\") %>%\n  set_mode(\"regression\")\n\ntrees_wf_set <- workflow_set(\n  preproc = list(trees_recipe = trees_recipe,\n                 trees_recipe = trees_recipe,\n                 trees_recipe_dummy = trees_recipe_dummy),\n  models = list(rf = rf_spec, decision = decision_spec, xgb = xgb_spec),\n  cross = FALSE\n)\n\nAs a first pass, I’ll let tune_grid() choose 10 parameter combinations automatically for each model (grid = 10):\n\nset.seed(225)\ntic()\ntrees_wf_set_res <- workflow_map(\n  trees_wf_set,\n  \"tune_grid\",\n  grid = 10, resamples = bike_resamples, metrics = bike_metrics,\n)\ntoc()\n\n100.33 sec elapsed\n\n\nVisualize the performance of the 30 workflows, ranked by MASE:\n\n# Don't need to use my custom function defined previously because I'm\n#  not using functionally different recipes for each model\nautoplot(trees_wf_set_res, rank_metric = \"mase\")\n\n\n\n\nAs I would have expected, the decision tree models generally perform worse than random forest models (which consist of multiple decision trees). The boosted tree models (which also consist of multiple decision trees, but differ in how they are built and combined) slightly outperform random forests, which is also expected.\nFor the three different tree-based model types, I’ll extract the best-performing workflows (by MASE) and fit to the full training set:\n\ndecision_workflow <- finalize_workflow(\n  extract_workflow(trees_wf_set_res, \"trees_recipe_decision\"),\n  extract_workflow_set_result(trees_wf_set_res, \"trees_recipe_decision\") %>%\n    select_best(metric = \"mase\")\n)\nrf_workflow <- finalize_workflow(\n  extract_workflow(trees_wf_set_res, \"trees_recipe_rf\"),\n  extract_workflow_set_result(trees_wf_set_res, \"trees_recipe_rf\") %>%\n    select_best(metric = \"mase\")\n)\nxgb_workflow <- finalize_workflow(\n  extract_workflow(trees_wf_set_res, \"trees_recipe_dummy_xgb\"),\n  extract_workflow_set_result(trees_wf_set_res, \"trees_recipe_dummy_xgb\") %>%\n    select_best(metric = \"mase\")\n)\n\ndecision_fit <- decision_workflow %>% fit(bike_train)\nrf_fit <- rf_workflow %>% fit(bike_train)\nxgb_fit <- xgb_workflow %>% fit(bike_train)\n\n\nModel interpretation\nDecision trees are the easiest of the three to interpret, but this decision tree is quite complicated. It has 44 leaf nodes (i.e. terminal nodes) with a depth of 6. The visualization (done with the rpart.plot package) is messy and hidden below:\n\n\nDecision tree plot\n\n\nextract_fit_engine(decision_fit) %>%\n  rpart.plot::rpart.plot(\n    # Using some options to try and make the tree more readable\n    fallen.leaves = FALSE, roundint = FALSE,\n    tweak = 5, type = 0, faclen = 10, clip.facs = TRUE, compress = FALSE\n  )\n\n\n\n\n\nThe nodes at the top of the tree are a good indicator of feature importance. Here, that was n_bikes_lag_14, followed by mean_temperature and total_precipitation.\nTo quantify the contribution of each feature in a tree-based model, we can calculate variable importance with the vip package. Plot the top 5 variables for all 3 models:\n\nlibrary(vip)\n\np1 <- extract_fit_engine(decision_fit) %>%\n  vip(num_features = 5) +\n  scale_y_continuous(NULL, expand = c(0, 0)) +\n  labs(subtitle = \"Decision tree\")\np2 <- extract_fit_engine(rf_fit) %>%\n  vip(num_features = 5) +\n  scale_y_continuous(NULL, expand = c(0, 0)) +\n  labs(subtitle = \"Random forest\")\np3 <- extract_fit_engine(xgb_fit) %>%\n  vip(num_features = 5) +\n  scale_y_continuous(NULL, expand = c(0, 0)) +\n  labs(subtitle = \"XGBoost\")\np1 + p2 + p3 +\n  plot_layout(ncol = 1)\n\n\n\n\nWe see that n_bikes_lag_14, mean_temperature, and site_name are important with all three models. Measures of time within (count_date_doy) and across (count_date_year) years are also important.\n\n\nXGBoost tuning\nSo far, I’ve only considered 10 candidate sets of hyperparameters for tuning each tree-based model. Let’s try 100 with XGBoost:\n\n# Get the number of predictors so I can set max number of predictors in `mtry()`\nbike_train_baked <- prep(trees_recipe_dummy) %>% bake(bike_train)\n\n# `grid_latin_hypercube()` is a space-filling parameter grid design that will\n#  efficiently cover the parameter space for me\nxgb_grid <- grid_latin_hypercube(\n  finalize(mtry(), select(bike_train_baked, -n_bikes)),\n  trees(), min_n(), tree_depth(), learn_rate(),\n  size = 100\n)\nxgb_grid\n\n# A tibble: 100 × 5\n    mtry trees min_n tree_depth learn_rate\n   <int> <int> <int>      <int>      <dbl>\n 1    14   300    20          8   4.27e- 4\n 2    30  1560     5         12   2.17e- 5\n 3    22  1723    30          2   1.37e- 2\n 4     2   268    21          2   6.42e-10\n 5     7   780    15         12   1.09e- 5\n 6    24   642    24          2   7.51e- 5\n 7     3  1066    36          3   8.06e- 9\n 8    13   725     4          6   1.94e- 2\n 9    18   574    40          9   5.55e- 7\n10    27  1988    38         13   7.08e- 9\n# … with 90 more rows\n# ℹ Use `print(n = ...)` to see more rows\n\n\nWe have just one model and one preprocessor now, so put it into a single workflow:\n\nxgb_workflow_2 <- workflow() %>%\n  add_recipe(trees_recipe_dummy) %>%\n  add_model(xgb_spec)\n\nAnd tune:\n\nset.seed(2081)\ntic()\nxgb_tune <- tune_grid(\n  xgb_workflow_2, resamples = bike_resamples,\n  grid = xgb_grid, metrics = bike_metrics\n)\ntoc()\n\n580.23 sec elapsed\n\n\nHere are the metrics for the different candidate models:\n\nautoplot(xgb_tune)\n\n\n\n\nFinalize the workflow with the best hyperparameters and fit the full training set:\n\nxgb_workflow_2 <- finalize_workflow(\n  xgb_workflow_2, select_best(xgb_tune, metric = \"mase\")\n)\n\nxgb_fit_2 <- xgb_workflow_2 %>% fit(bike_train)\n\n\n\n\nSupport vector machines\nLastly, I will try some support vector machine regressions with linear, polynomial and radial basis function (RBF) kernels:\n\n# New recipe for the SVMs which require a `step_normalize()`\nsvm_recipe <-\n  recipe(\n    n_bikes ~ count_date + site_name + n_bikes_lag_14 + mean_temperature + \n      total_precipitation + speed_max_gust + snow_on_ground,\n    data = bike_train, \n  ) %>% \n  update_role(count_date, new_role = \"date_variable\") %>%\n  step_date(count_date, features = c(\"dow\", \"doy\", \"year\"),\n            label = TRUE, ordinal = FALSE) %>%\n  step_holiday(count_date, holidays = canada_holidays) %>%\n  step_novel(all_nominal_predictors()) %>%\n  step_impute_mean(speed_max_gust) %>%\n  step_mutate_at(c(total_precipitation, snow_on_ground),\n                 fn = ~ replace_na(., 0)) %>%\n  step_zv(all_predictors()) %>% \n  step_normalize(all_numeric_predictors())\n\nsvm_linear_spec <- svm_linear(cost = tune(), margin = tune()) %>%\n  set_mode(\"regression\") %>%\n  set_engine(\"kernlab\")\n\nsvm_poly_spec <- svm_poly(cost = tune(), margin = tune(),\n                          scale_factor = tune(), degree = tune()) %>%\n  set_mode(\"regression\") %>%\n  set_engine(\"kernlab\")\n\nsvm_rbf_spec <-  svm_rbf(cost = tune(), rbf_sigma = tune()) %>% \n  set_mode(\"regression\") %>%\n  set_engine(\"kernlab\")\n\nsvm_wf_set <- workflow_set(\n  preproc = list(svm_recipe),\n  models = list(linear = svm_linear_spec, poly = svm_poly_spec,\n                rbf = svm_rbf_spec)\n)\n\n\nset.seed(4217)\nsvm_wf_set_res <- workflow_map(\n  svm_wf_set,\n  \"tune_grid\",\n  grid = 10, resamples = bike_resamples, metrics = bike_metrics\n)\n\n\nautoplot(svm_wf_set_res)\n\n\n\n\nThose are some pretty interesting (and smooth) trends. The best model is one of the svm_rbf candidates (though the next 10 are the svm_linear models). Finalize the workflows and fit:\n\nsvm_linear_wf_res <-\n  extract_workflow_set_result(svm_wf_set_res, \"recipe_linear\")\nsvm_linear_wf <-\n  finalize_workflow(\n    extract_workflow(svm_wf_set, \"recipe_linear\"),\n    select_best(svm_linear_wf_res, \"mase\")\n  )\nsvm_linear_fit <- fit(svm_linear_wf, bike_train)\n\nsvm_poly_wf_res <-\n  extract_workflow_set_result(svm_wf_set_res, \"recipe_poly\")\nsvm_poly_wf <-\n  finalize_workflow(\n    extract_workflow(svm_wf_set, \"recipe_poly\"),\n    select_best(svm_poly_wf_res, \"mase\")\n  )\nsvm_poly_fit <- fit(svm_poly_wf, bike_train)\n\nsvm_rbf_wf_res <-\n  extract_workflow_set_result(svm_wf_set_res, \"recipe_rbf\")\nsvm_rbf_wf <-\n  finalize_workflow(\n    extract_workflow(svm_wf_set, \"recipe_rbf\"),\n    select_best(svm_rbf_wf_res, \"mase\")\n  )\nsvm_rbf_fit <- fit(svm_rbf_wf, bike_train)"
  },
  {
    "objectID": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#choosing-a-final-model",
    "href": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#choosing-a-final-model",
    "title": "Predicting bike ridership: developing a model",
    "section": "Choosing a final model",
    "text": "Choosing a final model\nI’ll choose a model by the best cross-validated MASE:\n\nbind_rows(\n  rank_results(glm_wf_set_res, rank_metric = \"mase\",\n                     select_best = TRUE) %>%\n    # Only include the full pre-processing recipe\n    filter(str_detect(wflow_id, \"date_weather\")),\n  rank_results(trees_wf_set_res, rank_metric = \"mase\", select_best = TRUE),\n  rank_results(svm_wf_set_res, rank_metric = \"mase\", select_best = TRUE),\n  show_best(xgb_tune, metric = \"mase\", n = 1) %>%\n    mutate(model = \"boost_tree_2\")\n) %>%\n  filter(.metric == \"mase\") %>%\n  select(model, mase = mean, std_err) %>%\n  arrange(mase) %>%\n  gt() %>%\n  fmt_number(c(mase, std_err), decimals = 4)\n\n\n\n\n\n  \n  \n    \n      model\n      mase\n      std_err\n    \n  \n  \n    boost_tree_2\n0.4913\n0.0503\n    boost_tree\n0.4933\n0.0545\n    rand_forest\n0.5099\n0.0566\n    svm_rbf\n0.5420\n0.0440\n    poisson_reg\n0.5471\n0.0563\n    decision_tree\n0.5481\n0.0500\n    svm_linear\n0.5608\n0.0478\n    linear_reg\n0.5775\n0.0754\n    svm_poly\n0.6253\n0.0410\n  \n  \n  \n\n\n\n\nXGBoost takes the top two spots, with boost_tree_2 (the more thorough tuning) being the slight winner. Perform a last_fit() and get the performance on the held-out test set:\n\nxgb_final_fit <- last_fit(\n  xgb_workflow_2, split = bike_split, metrics = bike_metrics\n)\ncollect_metrics(xgb_final_fit) %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      .metric\n      .estimator\n      .estimate\n      .config\n    \n  \n  \n    rmse\nstandard\n42.8027205\nPreprocessor1_Model1\n    rsq\nstandard\n0.5487906\nPreprocessor1_Model1\n    mase\nstandard\n0.7146084\nPreprocessor1_Model1\n    poisson_log_loss\nstandard\nNaN\nPreprocessor1_Model1\n  \n  \n  \n\n\n\n\nThere’s a bit of a drop-off in performance from the training metrics. Let’s dig into the predictions.\n\nExploring the predictions\nPlot the relationship between actual n_bikes and predicted:\n\nxgb_final_preds <- bind_rows(\n  train = augment(extract_workflow(xgb_final_fit), bike_train),\n  test = augment(extract_workflow(xgb_final_fit), bike_test),\n  .id = \"data_set\"\n) %>%\n  mutate(data_set = fct_inorder(data_set))\n\nxgb_final_preds %>%\n  ggplot(aes(x = n_bikes, y = .pred)) +\n  geom_point() +\n  geom_abline(slope = 1, size = 1, color = td_colors$nice$emerald) +\n  facet_wrap(~ data_set)\n\n\n\n\nAnd here are the predictions overlaid on the data (vertical line delineates training and testing sets):\n\np <- xgb_final_preds %>%\n  ggplot(aes(x = count_date)) +\n  geom_line(aes(y = n_bikes, color = site_name), size = 1) +\n  geom_line(aes(y = .pred), color = \"black\") +\n  geom_vline(xintercept = min(bike_test$count_date), lty = 2) +\n  facet_wrap(~ site_name, ncol = 1, scales = \"free_y\") +\n  theme(legend.position = \"none\") +\n  scale_y_continuous(breaks = seq(0, 600, 200)) +\n  expand_limits(y = 200) +\n  dunnr::add_facet_borders()\np\n\n\n\n\nTruncate the dates to look closer at the testing set performance:\n\np + coord_cartesian(xlim = as.Date(c(\"2021-07-01\", \"2022-05-01\")))\n\n\n\n\nThis looks okay to my eye, though it does look to be overfitting the training set. It’s a shame to not have more data to test a full year – most of the test set covers winter and spring.5\nTo investigate the model performance further, I’ll plot the biggest outliers in the training and testing set (and ±1 week on either side):\n\nworst_preds <- xgb_final_preds %>%\n  mutate(abs_error = abs(n_bikes - .pred)) %>%\n  group_by(data_set, site_name) %>%\n  slice_max(abs_error, n = 1) %>%\n  ungroup() %>%\n  select(data_set, site_name, count_date, n_bikes, .pred, abs_error)\n\nsite_colors <- setNames(td_colors$pastel6[1:5], unique(worst_preds$site_name))\n\nworst_preds %>%\n  select(data_set, site_name, count_date) %>%\n  mutate(\n    worst_date = count_date,\n    count_date = map(count_date, ~ seq.Date(.x - 7, .x + 7, by = \"day\"))\n  ) %>%\n  unnest(count_date) %>%\n  left_join(xgb_final_preds,\n            by = c(\"data_set\", \"site_name\", \"count_date\")) %>%\n  filter(!is.na(n_bikes)) %>%\n  mutate(site_name = fct_inorder(site_name)) %>%\n  split(.$site_name) %>%\n  map(\n    ~ ggplot(., aes(x = count_date)) +\n      geom_line(aes(y = n_bikes, color = site_name)) +\n      geom_line(aes(y = .pred), color = \"black\") +\n      geom_vline(aes(xintercept = worst_date), lty = 2) +\n      facet_wrap(~ data_set, scales = \"free_x\", ncol = 2) +\n      dunnr::add_facet_borders() +\n      scale_color_manual(values = site_colors) +\n      scale_x_date(breaks = unique(.$worst_date)) +\n      expand_limits(y = 0) +\n      theme(legend.position = \"none\") +\n      labs(x = NULL, y = NULL,\n           subtitle = .$site_name[[1]])\n  ) %>%\n  reduce(`+`) +\n  plot_layout(ncol = 2)\n\n\n\n\nRelative to the noise in the data, that doesn’t look too bad. The Vernon St site has a series of n_bikes = 0 in a row that I’m guessing aren’t real (see aside). It was probably an issue with the counter, or maybe some construction on the street halting traffic for that period.\n\n\nThe Vernon St site has 6 dates with n_bikes = 0 all in a row:\n\nbike_ridership %>%\n  filter(site_name == \"Vernon St\", n_bikes == 0) %>%\n  pull(count_date)\n\n[1] \"2021-11-13\" \"2021-11-14\" \"2021-11-15\" \"2021-11-16\" \"2021-11-17\"\n[6] \"2021-11-18\"\n\n\nI also think some of the poor predictions can be explained by missing data. For instance, there are some poor predictions around 2021-11-23, where the model is over-estimating n_bikes at a few sites. Check out the weather around that day:\n\nbike_ridership %>%\n  filter(count_date > \"2021-11-20\", count_date < \"2021-11-26\") %>%\n  distinct(count_date, mean_temperature, total_precipitation,\n           speed_max_gust, snow_on_ground) %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      count_date\n      mean_temperature\n      total_precipitation\n      speed_max_gust\n      snow_on_ground\n    \n  \n  \n    2021-11-21\n3.2\nNA\nNA\n2\n    2021-11-22\n11.1\n42.2\n57\n2\n    2021-11-23\n6.1\nNA\n41\n1\n    2021-11-24\n0.1\nNA\n43\n1\n    2021-11-25\n3.7\nNA\n43\n1\n  \n  \n  \n\n\n\n\nThis happens to be around the time of a huge rain and wind storm in Nova Scotia that knocked out power for a lot of people. This is seen in the total_precipitation on 2021-11-22, but the next day is missing data so, in my pre-processing, it was imputed as 0, which is definitely a poor approximation of the truth. If I impute a large amount of rain (let’s say 15mm) for that date, here is how the predictions change:\n\naugment(\n  extract_workflow(xgb_final_fit),\n  xgb_final_preds %>%\n    filter(count_date == \"2021-11-23\") %>%\n    rename(.pred_old = .pred) %>%\n    mutate(total_precipitation = 15)\n) %>%\n  select(site_name, n_bikes, .pred_old, .pred_new = .pred) %>%\n  gt()\n\n\n\n\n\n  \n  \n    \n      site_name\n      n_bikes\n      .pred_old\n      .pred_new\n    \n  \n  \n    Dartmouth Harbourfront Greenway\n30\n137.51662\n59.39198\n    Hollis St\n19\n85.97115\n21.11964\n    South Park St\n59\n315.21432\n187.37488\n    Vernon St\n133\n169.32935\n85.16235\n    Windsor St\n26\n95.60495\n23.89534\n  \n  \n  \n\n\n\n\nThat is a much better prediction for a rainy and windy day."
  },
  {
    "objectID": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#conclusions",
    "href": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#conclusions",
    "title": "Predicting bike ridership: developing a model",
    "section": "Conclusions",
    "text": "Conclusions\nIn the end, the XGBoost model was able to best predict daily bike ridership.\nIs this model useful to anyone? Maybe. Is it useful just sitting on my computer? Definitely not. So in my next post, I’ll put this model into production."
  },
  {
    "objectID": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#reproducibility",
    "href": "posts/2022-04-29-predicting-bike-ridership-developing-a-model/predicting-bike-ridership-developing-a-model.html#reproducibility",
    "title": "Predicting bike ridership: developing a model",
    "section": "Reproducibility",
    "text": "Reproducibility\n\n\n\nSession info\n\n\n\n setting  value\n version  R version 4.2.1 (2022-06-23 ucrt)\n os       Windows 10 x64 (build 19044)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Canada.utf8\n ctype    English_Canada.utf8\n tz       America/Curacao\n date     2022-08-21\n pandoc   2.18 @ C:/Program Files/RStudio/bin/quarto/bin/tools/ (via rmarkdown)\n\n\n\n\n  \n\n\n\n\n\n\nGit repository\n\n\n\nLocal:    main C:/Users/tdunn/Documents/tdunn-quarto\nRemote:   main @ origin (https://github.com/taylordunn/tdunn-quarto.git)\nHead:     [cff964f] 2022-08-14: Converted the `predicting-bike-ridership-developing-a-model` post\n\n\n\nSource code, R environment"
  },
  {
    "objectID": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html",
    "href": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html",
    "title": "Predicting bike ridership: deploying the model",
    "section": "",
    "text": "R setup\nlibrary(tidyverse)\nlibrary(httr)\n\nlibrary(dunnr)\nextrafont::loadfonts(device = \"win\", quiet = TRUE)\ntheme_set(theme_td())\nset_geom_fonts()\nset_palette()"
  },
  {
    "objectID": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#introduction",
    "href": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#introduction",
    "title": "Predicting bike ridership: deploying the model",
    "section": "Introduction",
    "text": "Introduction\nThis is the last in a series of posts about predicting bike ridership in Halifax. Previously I:\n\nretrieved and prepared bicycle counter and weather data, then\ndeveloped and evaluated different machine learning models.\n\nHere, I will walk through my steps of putting the model into “production” on Google Cloud Platform (GCP):\n\ndeploying an ETL pipeline with BigQuery and Cloud Scheduler,\nautomating model training with Cloud Run and Pub/Sub,\nserving predictions with a REST API via the plumber package (try it out here), and\ndeveloping a Shiny app for visualizing predictions (try it out here).\n\nThe source code for everything, including the Dockerfiles, can be found on GitHub here."
  },
  {
    "objectID": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#creating-the-project",
    "href": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#creating-the-project",
    "title": "Predicting bike ridership: deploying the model",
    "section": "Creating the project",
    "text": "Creating the project\nBefore anything, I had to create and set up a new project on GCP that I called hfx-bike-ridership. In addition to the very detailed GCP documentation, there are lots of great resources out there to walk through all the steps, like this one. In brief: after creating the project, I had to enable billing on the project, activate various APIs, create credentials (OAuth client and service account), and install the Cloud SDK."
  },
  {
    "objectID": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#etl-pipeline",
    "href": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#etl-pipeline",
    "title": "Predicting bike ridership: deploying the model",
    "section": "ETL pipeline",
    "text": "ETL pipeline\nI next set up the ETL (extract, transform, load) pipeline to automatically extract the raw data from their sources, perform some transformations, and load it into a database.\nIn BigQuery, I created the bike_counts and weather data sets:\n\n\n\nI then wrote a script etl.R that retrieves and processes bike counter data from the Halifax open data platform, and weather data from the government of Canada. Most of the code there is copied from my previous post, except for the lines at the end to upload the data to BigQuery tables:\n\nbq_auth(\"oauth-client.json\")\n\nproject <- \"hfx-bike-ridership\"\n\ndaily_counts_table <- bq_table(project, \"bike_counts\", \"daily_counts\")\nweather_table <- bq_table(project, \"weather\", \"daily_report\")\n\nbq_table_upload(daily_counts_table,\n                value = bike_counts_daily, fields = bike_counts_daily,\n                create_disposition = \"CREATE_IF_NEEDED\",\n                write_disposition = \"WRITE_TRUNCATE\")\n\nbq_table_upload(weather_table,\n                value = climate_report_daily, fields = climate_report_daily,\n                create_disposition = \"CREATE_IF_NEEDED\",\n                write_disposition = \"WRITE_TRUNCATE\")\n\nThis uses the bigrquery package to authenticate (bq_auth()) using my OAuth credentials and upload (bq_table_upload()) the data (creates if missing, overwrites if existing) to the tables daily_counts and daily_report. Here is what BigQuery looked like after running this script:\n\n\n\nAnd the daily_counts table:\n\n\n\nPutting these data into BigQuery, as opposed to a Cloud Storage bucket for example, is convenient for quick queries when I don’t want to load the data into R, like this one to find days with zero bikes counted:\n\n\n\nI could have simply wrote the data to CSV files and uploaded them via the GCP console, but that would defeat the purpose of next step: automation. To deploy my etl.R script, I wrote a fairly simple Dockerfile:\n\nFROM rocker/tidyverse:latest\n\nRUN R -e \"install.packages(c('bigrquery', 'httr'), repos = 'http://cran.us.r-project.org')\"\n\nADD oauth-client.json /home/rstudio\nADD etl/etl.R /home/rstudio\n\nCMD Rscript /home/rstudio/etl.R\n\nExplaining how Docker works is a bit out of scope for this post1 but from top to bottom:\n\nFROM rocker/tidyverse:latest\n\nThe tidyverse Docker image provided by RStudio, which you can read more about here: https://hub.docker.com/r/rocker/tidyverse.\nThis image is a bit overkill for this simple script. If I were worried about the size and portability of my image, I would instead use the base R image https://hub.docker.com/_/r-base and install only the packages I need from tidyverse.\n\nRUN R -e \"install.packages(c('bigrquery', 'httr'), repos = 'http://cran.us.r-project.org')\"\n\nInstalls the other packages I need besides those that come with tidyverse.\nParticularly, httr for interacting with APIs, and bigrquery for BigQuery.\n\nADD oauth-client.json /home/rstudio and ADD etl/etl.R /home/rstudio\n\nAdd my GCP credentials the ETL script to the Docker container.\n\nCMD Rscript /home/rstudio/etl.R\n\nRun the script.\n\n\nI then built the image, tagged it, and pushed it to the Container Registry with these commands:\n\ndocker build -t hfx-bike-ridership-etl .\ndocker tag hfx-bike-ridership-etl gcr.io/hfx-bike-ridership/hfx-bike-ridership-etl\ndocker push gcr.io/hfx-bike-ridership/hfx-bike-ridership-etl:latest\n\nNow that it exists on GCP, I want to schedule this container to run every week through Cloud Build and Cloud Scheduler. I used the googleCloudRunner package and followed these instructions:\n\nlibrary(googleCloudRunner)\n\ncr_setup() # Define project ID and authenticate with credentials\n\nbuild <- cr_build_make(\"etl/hfx-bike-ridership-etl.yaml\")\n\ncr_schedule(\n  # Schedule for every Sunday at 12am\n  schedule = \"0 0 * * SUN\",\n  name = \"etl\",\n  httpTarget = cr_schedule_http(build),\n  region = \"northamerica-northeast1\"\n)\n\nHere is how the job showed up in Cloud Scheduler:\n\n\n\nAnd that’s the ETL taken care of. I left it for a day, and checked the data on Sunday morning to confirm that the data had been updated as expected."
  },
  {
    "objectID": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#model-tuning-and-training",
    "href": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#model-tuning-and-training",
    "title": "Predicting bike ridership: deploying the model",
    "section": "Model tuning and training",
    "text": "Model tuning and training\nWith the data in place, I then created a Cloud Storage bucket to store models, and wrote the tune.R script.\n\n\ntune.R\n# Setup -------------------------------------------------------------------\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(bigrquery)\nlibrary(googleCloudStorageR)\nlibrary(tictoc)\nsource(\"model/preprocess.R\")\n\nn_cores <- parallel::detectCores(logical = FALSE)\nlibrary(doParallel)\ncl <- makePSOCKcluster(n_cores - 1)\nregisterDoParallel(cl)\n# This extra step makes sure the parallel workers have access to the\n#  `tidyr::replace_na()` function during pre-processing\nparallel::clusterExport(cl, c(\"replace_na\"))\n\n# Read data ---------------------------------------------------\n\nbq_auth(path = \"oauth-client.json\")\n\n# Define the project, dataset and a new table for this project\nproject <- \"hfx-bike-ridership\"\n\ndaily_counts_table <- bq_table(project, \"bike_counts\", \"daily_counts\")\nbike_data <- bq_table_download(daily_counts_table)\nbike_data_updated <- bq_table_meta(daily_counts_table)$lastModifiedTime %>%\n  as.numeric() %>%\n  # `lastModifiedTime` is in milliseconds from 1970-01-01\n  {as.POSIXct(. / 1000, origin = \"1970-01-01\")}\n\nweather_table <- bq_table(project, \"weather\", \"daily_report\")\nweather_data <- bq_table_download(weather_table)\nweather_data_updated <- bq_table_meta(weather_table)$lastModifiedTime %>%\n  as.numeric() %>%\n  {as.POSIXct(. / 1000, origin = \"1970-01-01\")}\n\n# Pre-process -------------------------------------------------------------\n\nbike_data <- preprocess(bike_data, weather_data)\n\n# Splitting and resampling ------------------------------------------------\n\n# For the initial time split, data is ordered by date so that the training\n#  data consists of the earliest dates across all sites\nbike_data <- bike_data %>% arrange(count_date, site_name)\nbike_split <- initial_time_split(bike_data, prop = 0.7)\n\nbike_train <- training(bike_split)\nbike_test <- testing(bike_split)\n\n# ... but once I'm done splitting the data, I want to order by site followed by\n#  date for two reasons:\n#  (1) `step_impute_roll()` looks for rows in a window (ordered)\n#  (2) the `mase` metric compares predictions to the naive prediction, which\n#      uses the previous value\nbike_train <- bike_train %>% arrange(count_date, site_name)\nbike_test <- bike_test %>% arrange(count_date, site_name)\n\nbike_resamples <-\n  sliding_period(bike_train, index = count_date,\n                 period = \"month\", lookback = 13, assess_stop = 1)\n\n# For model versioning, record the splitting and resampling strategy\nsplits_resamples <- tibble(\n  n_data = nrow(bike_data), n_train = nrow(bike_train), n_test = nrow(bike_test),\n  min_date_train = min(bike_train$count_date),\n  max_date_train = max(bike_train$count_date),\n  min_date_test = min(bike_test$count_date),\n  max_date_test = max(bike_test$count_date),\n  prop = 0.7, resamples = \"sliding_period\",\n  resample_params = \"lookback = 13, assess_stop = 1\"\n)\n\n# Features ------------------------------------------------------------------\n\n# Get Canadian holidays\ncanada_holidays <-\n  timeDate::listHolidays(\n    pattern = \"^CA|^Christmas|^NewYears|Easter[Sun|Mon]|^GoodFriday|^CaRem\"\n  )\n\nbike_recipe <-\n  recipe(n_bikes ~ count_date + site_name + n_bikes_lag_14 +\n           mean_temperature + total_precipitation + speed_max_gust +\n           snow_on_ground,\n         data = bike_train) %>%\n  update_role(count_date, new_role = \"date_variable\") %>%\n  step_date(count_date, features = c(\"dow\", \"doy\", \"year\"),\n            label = TRUE, ordinal = FALSE) %>%\n  step_holiday(count_date, holidays = canada_holidays) %>%\n  step_novel(all_nominal_predictors()) %>%\n  step_dummy(all_nominal_predictors()) %>%\n  step_impute_mean(speed_max_gust) %>%\n  step_mutate_at(c(total_precipitation, snow_on_ground),\n                 fn = ~ replace_na(., 0)) %>%\n  # Use a rolling window to impute temperature\n  step_impute_roll(mean_temperature, statistic = mean, window = 31) %>%\n  step_zv(all_predictors())\n\n\n# Model spec and workflow -----------------------------------------------------\n\nxgb_spec <- boost_tree(\n  mtry = tune(), trees = tune(), min_n = tune(),\n  tree_depth = tune(), learn_rate = tune()\n) %>%\n  set_engine(\"xgboost\") %>%\n  set_mode(\"regression\")\n\nbike_xgb_workflow <- workflow() %>%\n  add_recipe(bike_recipe) %>%\n  add_model(xgb_spec)\n\nbike_train_baked <- prep(bike_recipe) %>% bake(bike_train)\n\nxgb_grid <- grid_latin_hypercube(\n  finalize(mtry(), select(bike_train_baked, -n_bikes)),\n  trees(), min_n(), tree_depth(), learn_rate(),\n  size = 100\n)\n\n# Tune --------------------------------------------------------------------\n\nbike_metrics <- metric_set(rmse, mae, rsq, mase)\n\nset.seed(944)\ntic()\nxgb_tune <- tune_grid(\n  bike_xgb_workflow, resamples = bike_resamples,\n  grid = xgb_grid, metrics = bike_metrics\n)\ntoc()\n\n# Choose the hyperparameters by MASE\nxgb_params <- select_best(xgb_tune, metric = \"mase\")\n# Also get all the metrics on the training for the chosen parameters\ntrain_metrics <- xgb_params %>%\n  left_join(\n    collect_metrics(xgb_tune) %>%\n      select(.metric, mean, n, std_err, .config),\n    by = \".config\"\n  )\n\n# Finalize and fit to the full training set\nbike_xgb_workflow_final <- finalize_workflow(bike_xgb_workflow, xgb_params)\nbike_xgb_fit <- bike_xgb_workflow_final %>% fit(bike_train)\n\n# Predict on the test set and get metrics\ntest_metrics <- bike_xgb_fit %>%\n  augment(bike_test) %>%\n  bike_metrics(truth = n_bikes, estimate = .pred)\n\n# Compile the model and  info into a list\nmodel_tuned <- list(\n  timestamp = Sys.time(),\n  bike_data_updated = bike_data_updated,\n  weather_data_updated = weather_data_updated,\n  splits_resamples = splits_resamples,\n  xgb_params = xgb_params,\n  train_metrics = train_metrics,\n  test_metrics = test_metrics,\n  bike_xgb_fit = bike_xgb_fit\n)\n\n# Save model and model info -----------------------------------------------\n\n# Model object\nwrite_rds(model_tuned, \"model/tune/xgb-model-tuned.rds\")\ngcs_upload_set_limit(20000000L) # 20 Mb\nmetadata <- gcs_upload(\"model/tune/xgb-model-tuned.rds\",\n                       name = \"tune/xgb-model-tuned.rds\",\n                       bucket = \"hfx-bike-ridership-model\")\ntimestamp <- as.POSIXct(metadata$updated,\n                        tryFormats = \"%Y-%m-%dT%H:%M:%OS\", tz = \"GMT\")\n\n# XGB hyperparameters\nxgb_params <- xgb_params %>%\n  mutate(timestamp = model_tuned$timestamp) %>%\n  select(-.config)\nwrite_csv(xgb_params, \"model/tune/xgb-params.csv\",\n          append = TRUE, col_names = FALSE)\nparams_table <- bq_table(project, \"model_info\", \"params\")\nbq_table_upload(params_table,\n                value = xgb_params, fields = xgb_params,\n                create_disposition = \"CREATE_IF_NEEDED\",\n                write_disposition = \"WRITE_APPEND\")\n\n# Model metrics\nxgb_metrics <- bind_rows(\n  train = train_metrics %>%\n    select(metric = .metric, value = mean, n, std_err),\n  test = test_metrics %>%\n    select(metric = .metric, value = .estimate),\n  .id = \"data_set\"\n) %>%\n  mutate(timestamp = model_tuned$timestamp)\nwrite_csv(xgb_metrics, \"model/tune/xgb-metrics.csv\",\n          append = TRUE, col_names = FALSE)\nmetrics_table <- bq_table(project, \"model_info\", \"metrics\")\nbq_table_upload(metrics_table,\n                value = xgb_metrics, fields = xgb_metrics,\n                create_disposition = \"CREATE_IF_NEEDED\",\n                write_disposition = \"WRITE_APPEND\")\n\n# Splitting and resampling strategy\nsplits_resamples <- splits_resamples %>%\n  mutate(timestamp = model_tuned$timestamp)\nwrite_csv(splits_resamples, \"model/tune/splits-resamples.csv\",\n          append = TRUE, col_names = FALSE)\nsplits_resamples_table <- bq_table(project, \"model_info\", \"splits_resamples\")\nbq_table_upload(splits_resamples_table,\n                value = splits_resamples, fields = splits_resamples,\n                create_disposition = \"CREATE_IF_NEEDED\",\n                write_disposition = \"WRITE_APPEND\")\n\n\nThis actual model code and choices are mostly unchanged from my last post, but in brief it: retrieves the latest data from BigQuery, splits the data into training and testing, creates resamples, engineers features, tunes the XGBoost model, finds the best hyperparameters by MASE, and saves the model (as an R object) to the bucket. I also decided to keep track of metrics with a BigQuery table:\n\n\n\nI decided to keep this part of the pipeline manual. Tuning the XGBoost model takes a while on my machine, even with parallel processing, and I’ve heard enough horror stories of surprise charges from cloud services that I don’t feel like risking it. I will periodically check in on my model predictions, and only plan on re-tuning if performance degrades appreciably.\nWhat I will automate, however, is model training. Every time the data is updated (i.e. Sundays at midnight), I want to train the tuned model on the full data set. The idea is pretty simple: get the data from BigQuery, the tuned model from the bucket, fit to the data and save that fit to the same bucket. The tricky bit is that I want this process to trigger only when the data is updated. It turns out that BigQuery currently doesn’t have native functionality to trigger Cloud Run, so I had to use a workaround.\nFirst, I wrote the fit.R function to work as a plumber API (these instructions were helpful):\n\n\nfit.R\nlibrary(dplyr)\nlibrary(readr)\nlibrary(tidymodels)\nlibrary(bigrquery)\nlibrary(googleCloudStorageR)\nlibrary(googleCloudRunner)\nlibrary(plumber)\nsource(\"preprocess.R\")\n\nbq_auth(path = \"oauth-client.json\")\ngcs_auth(\"oauth-client.json\")\ngcs_upload_set_limit(20000000L) # 20 Mb\n\n# This function will retrieve the latest data from BigQuery, the trained\n#  model from GCS, and fit an XGBoost model, which is saved to GCS\npub <- function(message) {\n  # Define the project, dataset and a new table for this project\n  project <- \"hfx-bike-ridership\"\n\n  daily_counts_table <- bq_table(project, \"bike_counts\", \"daily_counts\")\n  bike_data <- bq_table_download(daily_counts_table)\n  bike_data_updated <- bq_table_meta(daily_counts_table)$lastModifiedTime %>%\n    as.numeric() %>%\n    {as.POSIXct(. / 1000, origin = \"1970-01-01\")}\n\n\n  weather_table <- bq_table(project, \"weather\", \"daily_report\")\n  weather_data <- bq_table_download(weather_table)\n  weather_data_updated <- bq_table_meta(weather_table)$lastModifiedTime %>%\n    as.numeric() %>%\n    {as.POSIXct(. / 1000, origin = \"1970-01-01\")}\n\n  bike_data <- preprocess(bike_data, weather_data)\n  xgb_tuned <- gcs_get_object(\"tune/xgb-model-tuned.rds\",\n                              bucket = \"hfx-bike-ridership-model\",\n                              parseFunction = gcs_parse_rds)\n\n  message(\"Writing updating xgb-fit\")\n  xgb_fit <- list(\n    tune_timestamp = xgb_tuned$timestamp,\n    timestamp = Sys.time(),\n    bike_data_updated = bike_data_updated,\n    weather_data_updated = weather_data_updated,\n    bike_xgb_fit = fit(xgb_tuned$bike_xgb_fit, bike_data)\n  )\n\n  f <- function(input, output) write_rds(input, output)\n  metadata <- gcs_upload(xgb_fit, name = \"xgb-fit.rds\",\n                         bucket = \"hfx-bike-ridership-model\",\n                         object_function = f)\n\n  return(TRUE)\n}\n\n#' Receive pub/sub message\n#' @post /pubsub\n#' @param message a pub/sub message\nfunction(message = NULL) {\n  message(\"Received message \", message)\n  googleCloudRunner::cr_plumber_pubsub(message, pub)\n}\n\n\nI wrote a Docker file to containerize the API, built the image, and pushed it to the Container Registry. I then went to Cloud Run, created a new service called hfx-bike-ridership-fit using the just-uploaded Docker image:\n\n\n\nOnce up and running, this gave me a URL from which to query the API:\n\n\n\nNext, I had to set up an internal messaging system. The steps were:\n\nI added a message(\"Finished ETL pipeline\") at the end of the etl.R script to indicate that the data was updated.\nThis message shows up in Cloud Logging, so I added a “sink” (which is how Logging routes messages) to look for this specific log.\n\n\n\n\n\nThe destination of this sink is a Pub/Sub topic called data-updated.\nI added a subscription to this topic which pushes a POST request to the API.\n\n\n\n\n\nThe POST request triggers the model fitting code, and the new model is uploaded to the Storage bucket.\n\nThis seems like a complex workaround for a fairly simple task – I might be missing an easier method. Also, it may have made more sense to just have the model re-train on a weekly schedule (just after the ETL pipeline), but I wanted more flexibility for ad hoc updates. Regardless, both the ETL and model training are now fully automated."
  },
  {
    "objectID": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#deployment",
    "href": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#deployment",
    "title": "Predicting bike ridership: deploying the model",
    "section": "Deployment",
    "text": "Deployment\n\nREST API\nTo serve predictions, I wrote another plumber API in the api.R script:\n\n\napi.R\n#* @apiTitle Predict bike ridership in Halifax, NS\n#* @apiDescription This API serves predictions for the daily number of bicyclists passing particular sites around Halifax, Nova Scotia. For more information, check out the [source code](https://github.com/taylordunn/hfx-bike-ridership), my [post about the data](https://tdunn.ca/posts/2022-04-27-predicting-bike-ridership-getting-the-data/), and [my post about developing the model](https://tdunn.ca/posts/2022-04-29-predicting-bike-ridership-developing-a-model/).\n#* @apiContact list(name = \"Taylor Dunn\", url = \"http://www.tdunn.ca\", email = \"t.dunn19@gmail.com\")\n#* @apiVersion 1.0\n\nlibrary(plumber)\nlibrary(dplyr)\nlibrary(tidymodels)\nlibrary(bigrquery)\nlibrary(googleCloudStorageR)\n\nbq_auth(path = \"oauth-client.json\",\n        email = \"hfx-bike-ridership@hfx-bike-ridership.iam.gserviceaccount.com\")\ngcs_auth(\"oauth-client.json\")\n\nproject <- \"hfx-bike-ridership\"\n\nmessage(\"Reading data\")\ndaily_counts_table <- bq_table(project, \"bike_counts\", \"daily_counts\")\nbike_data <- bq_table_download(daily_counts_table)\n\nmessage(\"Loading model\")\nxgb_fit <- gcs_get_object(\"xgb-fit.rds\", bucket = \"hfx-bike-ridership-model\",\n                          parseFunction = gcs_parse_rds)\n\nsite_names <- c(\"Dartmouth Harbourfront Greenway\", \"Hollis St\",\n                \"South Park St\", \"Vernon St\", \"Windsor St\")\n\n#* @param count_date:str The date in YYYY-MM-DD format.\n#* @param site_name:[str] The location of the bike counter. One of \"Dartmouth Harbourfront Greenway\", \"Hollis St\", \"South Park St\", \"Vernon St\", \"Windsor St\".\n#* @param n_bikes_lag_14:[int] The number of bikes measured at the given `site_name` 14 days ago. If not provided, will attempt to impute with the actual value 14 days before `count_date`.\n#* @param mean_temperature:numeric The daily mean temperature. If not provided, will impute with the rolling mean.\n#* @param total_precipitation:numeric The daily amount of precipitation in mm. If not provided, will impute with zero.\n#* @param snow_on_ground:numeric The daily amount of snow on the ground in cm. If not provided, will impute with zero.\n#* @param speed_max_gust:numeric The daily maximum wind speed in km/h. If not provided, will impute with the mean in the training set.\n#* @get /n_bikes\nfunction(count_date, site_name = NA_character_, n_bikes_lag_14 = NA_integer_,\n         mean_temperature = NA_real_, total_precipitation = NA_real_,\n         snow_on_ground = NA_real_, speed_max_gust = NA_real_) {\n\n  # If not provided, use all `site_name`s\n  if (any(is.na(site_name))) {\n    site_name <- site_names\n  } else {\n    site_name <- match.arg(\n      site_name, choices = site_names, several.ok = TRUE\n    )\n  }\n\n  count_date <- as.Date(count_date)\n\n  # Get the 14-day lagged bike counts for each site\n  if (!is.na(n_bikes_lag_14) & length(site_name) != length(n_bikes_lag_14)) {\n    return(list(\n      status = 400,\n      message = \"Must provide a value of `n_bikes_lag_14` for every given `site_name`.\"\n    ))\n  } else {\n    d <- tibble(site_name = .env$site_name, count_date = .env$count_date,\n                count_date_lag_14 = count_date - 14,\n                n_bikes_lag_14 = .env$n_bikes_lag_14)\n\n    if (sum(is.na(d$n_bikes_lag_14)) > 0) {\n      message(\"Imputing `n_bikes_lag_14`\")\n      d <- d %>%\n        left_join(\n          bike_data %>%\n            select(site_name, count_date_lag_14 = count_date,\n                   n_bikes_lag_14_impute = n_bikes),\n          by = c(\"site_name\", \"count_date_lag_14\")\n        ) %>%\n        mutate(\n          n_bikes_lag_14 = ifelse(is.na(n_bikes_lag_14),\n                                  n_bikes_lag_14_impute, n_bikes_lag_14)\n        ) %>%\n        select(-n_bikes_lag_14_impute)\n\n      if (sum(is.na(d$n_bikes_lag_14)) > 0) {\n        return(list(\n          status = 400,\n          message = paste0(\n            \"Could not find `n_bikes_lag_14` values on date \", count_date,\n            \" for these sites \",\n            filter(d, is.na(n_bikes_lag_14)) %>% pull(site_name) %>% paste(collapse = \", \"),\n            \". Please provide your own `n_bikes_lag_14`, or choose a different `count_date`.\"\n          )\n        ))\n      }\n    }\n  }\n\n  # Add weather variables\n  d <- d %>%\n    mutate(\n      n_bikes_lag_14 = as.numeric(n_bikes_lag_14),\n      mean_temperature = as.numeric(mean_temperature),\n      total_precipitation = as.numeric(total_precipitation),\n      snow_on_ground = as.numeric(snow_on_ground),\n      speed_max_gust = as.numeric(speed_max_gust)\n    )\n\n  augment(xgb_fit$bike_xgb_fit, d)\n}\n\n#* @get /model_info\n#* @response 200 Returns model information: timestamps of when the model was last trained (`timestamp`), the model was last tuned (`tune_timestamp`), the bicycle data was last updated (`bike_data_updated`), the weather data was last updated (`weather_data_updated`).\nfunction() {\n  list(\n    timestamp = xgb_fit$timestamp,\n    tune_timestamp = xgb_fit$tune_timestamp,\n    bike_data_updated = xgb_fit$bike_data_updated,\n    weather_data_updated = xgb_fit$weather_data_updated\n  )\n}\n\n\nThis reads in the model from the Cloud Storage bucket and the latest bike data from BigQuery. As inputs, it requires only a single date (count_date), for which it will return predictions for all 5 sites. One or more specific sites can also be provided (site_name). If the lagged values (n_bikes_lag_14) are not provided, then they will be imputed from the bike data (an error will be returned if the lagged value cannot be imputed, i.e. there is no data 14 days before count_date). The weather inputs mean_temperature, total_precipitation, snow_on_ground, and speed_max_gust are imputed if not provided.\nAs with fit.R, I put this into a Docker container, pushed to Container Registry, and created a Cloud Run service hfx-bike-ridership-api using that image.\n\nUnlike the previous Cloud Run service which only accepts internal requests, this one is publicly available. For instance, you can get a prediction for n_bikes on Hollis St for May 23rd, 2022 with the following R code:\n\nbase_url <- \"https://hfx-bike-ridership-api-74govvz7xq-uc.a.run.app/\"\nquery <- \"n_bikes?count_date=2022-05-23&site_name=Hollis St\"\n\npaste0(base_url, query) %>%\n  URLencode() %>%\n  GET() %>%\n  content(as = \"parsed\") %>%\n  purrr::flatten()\n\n$site_name\n[1] \"Hollis St\"\n\n$count_date\n[1] \"2022-05-23\"\n\n$count_date_lag_14\n[1] \"2022-05-09\"\n\n$n_bikes_lag_14\n[1] 86\n\n$.pred\n[1] 31.7664\n\n\nA great feature of plumber is that provides an HTML interface for documenting and interacting with REST APIs. Check out this API here: https://hfx-bike-ridership-api-74govvz7xq-uc.a.run.app/docs/.\n\n\nScreenshot for posterity\n\n\n\nI also added a model_info option, which can be queried to see timestamps of when the model was last tuned and trained, and when the data were last updated:\n\nquery <- \"model_info\"\npaste0(base_url, query) %>%\n  URLencode() %>%\n  GET() %>%\n  content(as = \"parsed\") %>%\n  purrr::flatten()\n\n$timestamp\n[1] \"2022-08-21 04:02:28\"\n\n$tune_timestamp\n[1] \"2022-05-20 15:23:46\"\n\n$bike_data_updated\n[1] \"2022-08-21 04:02:06\"\n\n$weather_data_updated\n[1] \"2022-08-21 04:02:10\"\n\n\n\n\nShiny dashboard\nLastly, I wrote a Shiny dashboard to visualize predictions, app.R:\n\n\napp.R\nlibrary(shiny)\nlibrary(shinydashboard)\nlibrary(dplyr)\nlibrary(readr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(workflows)\nlibrary(bigrquery)\nlibrary(googleCloudStorageR)\nlibrary(DT)\nlibrary(dunnr)\nsource(\"funcs.R\")\n\n# Plotting\nlibrary(showtext)\nsysfonts::font_add_google(\"Roboto Condensed\")\nshowtext_auto()\ntheme_set(theme_td(base_size = 14))\nset_geom_fonts()\nset_palette()\n\n# Authentication to GCP\nproject <- \"hfx-bike-ridership\"\nbq_auth(path = \"oauth-client.json\")\ngcs_auth(\"oauth-client.json\")\nbike_counts_table <- bq_table(project, \"bike_counts\", \"daily_counts\")\nweather_table <- bq_table(project, \"weather\", \"daily_report\")\n\nserver <- function(input, output, session) {\n  # Import data and model ---------------------------------------------------\n  data <- reactiveValues()\n  min_date <- reactiveVal()\n  max_date <- reactiveVal()\n  model <- reactiveVal()\n\n  observe({\n    # Re-reads data every hour\n    invalidateLater(1000 * 60 * 60)\n\n    message(\"Reading data and model\")\n    bike_data_raw <- bq_table_download(bike_counts_table)\n    weather_data_raw <- bq_table_download(weather_table)\n    model(gcs_get_object(\"xgb-fit.rds\",\n                         bucket = \"hfx-bike-ridership-model\",\n                         parseFunction = gcs_parse_rds))\n\n    bike_data <- bike_data_raw %>%\n      preprocess_bike_data() %>%\n      # Only include the last 14 days\n      filter(count_date >= max(count_date) - 13)\n    min_date(min(bike_data$count_date))\n    max_date(max(bike_data$count_date))\n    bike_data_future <- bike_data %>%\n      transmute(\n        count_date = count_date + 14, site_name, n_bikes_lag_14 = n_bikes\n      )\n\n    weather_data <- weather_data_raw %>%\n      preprocess_weather_data() %>%\n      filter(report_date >= min(bike_data$count_date),\n             report_date <= max(bike_data$count_date))\n    weather_data_future <- weather_data %>%\n      transmute(\n        report_date = report_date + 14,\n        # Impute temperature and wind speed with the mean\n        mean_temperature = round(mean(weather_data$mean_temperature,\n                                      na.rm = TRUE), 1),\n        speed_max_gust = round(mean(weather_data$speed_max_gust,\n                                    na.rm = TRUE)),\n        # Impute precipitation and snow with zero\n        total_precipitation = 0, snow_on_ground = 0\n      )\n\n    data$bike <- bind_rows(bike_data, bike_data_future)\n    data$weather <- bind_rows(weather_data, weather_data_future)\n  })\n\n  bike_weather_data <- reactive({\n    data$bike %>%\n      left_join(data$weather, by = c(\"count_date\" = \"report_date\"))\n  })\n\n  # Model info --------------------------------------------------------------\n  output$model_info_1 <- renderText({\n    HTML(\n      paste(\n        \"This Shiny app visualizes predictions of the daily number of bicyclists passing various bike counter sites around Halifax, Nova Scotia, in a four-week window.\",\n        \"Check out the <a href='https://github.com/taylordunn/hfx-bike-ridership'>source code here</a>, and <a href='https://tdunn.ca/posts/2022-05-19-predicting-bike-ridership-deploying-the-model/'>this write-up</a> for more information.\",\n        paste0(\"<br>Data are updated, and the model is re-trained on a schedule: currently every Sunday at midnight AST, and sometimes manually by me. \",\n               \"The current data go up to \",\n               \"<b>\", max_date(), \"</b>\",\n               \" as indicated by the vertical dashed line in the plots.\"),\n        \"<br>The locations of the sites are overlaid on a map of Halifax below:\",\n        sep = \"<br>\"\n      )\n    )\n  })\n\n  output$model_info_2 <- renderText({\n    HTML(\n      paste(\n        \"<br>\",\n        \"In addition to site, other features of the model are:\",\n        paste0(\"<ul>\",\n               \"<li>date features: day of week, day of year, year, and Canadian holidays</li>\",\n               \"<li>the number of bikes counted 14 days ago</li>\",\n               \"<li>weather features: daily mean temperature, total precipitation, maximum gust speed, and snow on the ground\",\n               \"</ul>\"),\n        \"See more information about the features and how missing data are handled <a href='https://tdunn.ca/posts/2022-04-29-predicting-bike-ridership-developing-a-model/'>in this post</a>.\",\n        \"<br>\"\n      )\n    )\n  })\n\n  # Plotting helpers --------------------------------------------------------\n  scale_x <- reactive({\n    scale_x_date(NULL, limits = c(min_date() - 1, max_date() + 14),\n                 breaks = seq.Date(min_date() - 1, max_date() + 14, \"7 days\"),\n                 date_labels = \"%b %d\")\n  })\n  vline <- reactive({\n    geom_vline(xintercept = max_date(), lty = 2, size = 1)\n  })\n\n  # Bike predictions --------------------------------------------------------\n  output$n_bikes_plot <- renderPlot({\n    workflows:::augment.workflow(model()$bike_xgb_fit,\n                                 bike_weather_data()) %>%\n      ggplot(aes(x = count_date)) +\n      vline() +\n      geom_line(aes(y = .pred), color = \"black\", size = 1) +\n      geom_point(aes(y = n_bikes, fill = site_name),\n                 color = \"black\", shape = 21, size = 4) +\n      facet_wrap(~ site_name, ncol = 1) +\n      expand_limits(y = 0) +\n      labs(y = NULL) +\n      scale_x() +\n      labs(title = \"Number of bikes vs date\",\n           subtitle = \"Coloured points show actual values, black lines are predictions\") +\n      theme(legend.position = \"none\") +\n      dunnr::add_facet_borders()\n  })\n\n  # Weather data ------------------------------------------------------------\n  temperature_plot <- reactive({\n    data$weather %>%\n      filter(!is.na(mean_temperature)) %>%\n      mutate(var = \"Mean daily temperature (celsius)\") %>%\n      ggplot(aes(x = report_date, y = mean_temperature)) +\n      vline() +\n      geom_point(fill = td_colors$nice$strong_red, shape = 21, size = 4) +\n      facet_wrap(~ var) +\n      labs(y = NULL,\n           title = \"Weather vs date\",\n           subtitle = \"Use the table below to edit values for prediction\") +\n      scale_x() +\n      theme(axis.text.x = element_blank()) +\n      dunnr::add_facet_borders()\n  })\n  precipitation_plot <- reactive({\n    data$weather %>%\n      filter(!is.na(total_precipitation)) %>%\n      mutate(var = \"Total daily precipitation (mm)\") %>%\n      ggplot(aes(x = report_date, y = total_precipitation)) +\n      vline() +\n      geom_col(fill = td_colors$nice$spanish_blue, color = \"black\") +\n      facet_wrap(~ var) +\n      expand_limits(y = 5) +\n      scale_y_continuous(NULL, expand = expansion(mult = c(0, 0.05))) +\n      scale_x() +\n      theme(axis.text.x = element_blank()) +\n      dunnr::add_facet_borders()\n  })\n\n  snow_plot <- reactive({\n    data$weather %>%\n      filter(!is.na(snow_on_ground)) %>%\n      mutate(var = \"Snow on ground (cm)\") %>%\n      ggplot(aes(x = report_date, y = snow_on_ground)) +\n      vline() +\n      geom_col(fill = td_colors$nice$charcoal, color = \"black\") +\n      facet_wrap(~ var) +\n      expand_limits(y = 5) +\n      scale_y_continuous(NULL, expand = expansion(mult = c(0, 0.05))) +\n      scale_x() +\n      theme(axis.text.x = element_blank()) +\n      dunnr::add_facet_borders()\n  })\n  wind_plot <- reactive({\n    data$weather %>%\n      filter(!is.na(speed_max_gust)) %>%\n      mutate(var = \"Maximum wind gust (km/h)\") %>%\n      ggplot(aes(x = report_date, y = speed_max_gust)) +\n      vline() +\n      geom_point(fill = td_colors$nice$emerald, shape = 21, size = 4) +\n      facet_wrap(~ var) +\n      labs(y = NULL) +\n      scale_x()\n  })\n\n  output$weather_plot <- renderPlot({\n    temperature_plot() +\n      precipitation_plot() +\n      snow_plot() +\n      wind_plot() +\n      plot_layout(ncol = 1)\n  })\n\n  output$weather_table <- renderDataTable(\n    datatable(\n      data$weather,\n      rownames = FALSE, escape = FALSE,\n      colnames = c(\"Date\", \"Temp.\", \"Precip.\", \"Snow\", \"Wind\"),\n      editable = list(target = \"cell\", numeric = c(2, 3, 4, 5)),\n      options = list(pageLength = 7, dom = \"tp\"),\n      caption = \"Double click a cell to edit values. Plots and predictions will update automatically.\"\n    ) %>%\n      DT::formatStyle(names(data$weather), lineHeight = \"80%\")\n  )\n\n  observeEvent(input$weather_table_cell_edit, {\n    row <- input$weather_table_cell_edit$row\n    col <- input$weather_table_cell_edit$col\n    data$weather[row, col + 1] <- input$weather_table_cell_edit$value\n  })\n}\n\nui <- dashboardPage(\n  skin = \"yellow\",\n  dashboardHeader(title = \"Predicting bike ridership in Halifax, NS\",\n                  titleWidth = 500),\n  dashboardSidebar(disable = TRUE),\n  dashboardBody(\n    tags$head(\n      tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"custom.css\")\n    ),\n    fluidRow(\n    column(\n      width = 3,\n      box(\n        title = HTML(paste0(as.character(icon(\"info\")), \" <b>Info</b>\")),\n        width = 12,\n        style = \"overflow-x: scroll;\",\n        uiOutput(\"model_info_1\"),\n        img(src = \"bike-counter-sites.png\",\n            style = \"width: 300px; display: block; margin-left: auto; margin-right: auto;\"),\n        uiOutput(\"model_info_2\")\n      )\n    ),\n    column(\n      width = 5,\n      box(\n        width = 12,\n        style = \"overflow-x: scroll;\",\n        plotOutput(\"n_bikes_plot\", height = \"800px\")\n      )\n    ),\n    column(\n      width = 4,\n      box(\n        width = 12,\n        style = \"overflow-x: scroll;\",\n        plotOutput(\"weather_plot\", height = \"600px\"),\n        dataTableOutput(\"weather_table\")\n      )\n    )\n  )\n  )\n)\n\nshinyApp(ui, server)\n\n\nI wrote the Docker file, pushed it to Container Registry, and deployed on Cloud Run.\nAssuming I haven’t shut it down (and that my billing information is not out of date), you can try the app here or embedded below:\n\n\n\n\n\n\n\n\nIn terms of design, I went with a three column layout with content organized into shinydashboard::box()s. The left-most column has some basic information, including the date of when the data and model were last updated. I also included a map showing the locations of the five sites:\n\n\n\nThe main interest of this dashboard is the forecasted number of bikes, so it takes the centre column:\n\nThere is a lot of data involved in this proejct, but I decided to keep this app fairly small in scope. Just the last 14 days and the next 14 days (relative to the when data/model were updated) are shown here.\nThe third column shows the most interesting predictors of the model – the weather variables:\n\n\n\nThe 14 days to the left of the dashed line are actual values, and the 14 days to right right are imputed future values.2 The table at the bottom lists all of the visualized weather data. To add some interactivity, I decided to make this part editable:\n\nEverything is reactive to this table, so the plots will be updated immediately:\n\nand so will the predictions:\n\nThis allows me to ask questions like: how will the predicted number of bicyclists change if it downpours tomorrow?"
  },
  {
    "objectID": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#conclusion",
    "href": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#conclusion",
    "title": "Predicting bike ridership: deploying the model",
    "section": "Conclusion",
    "text": "Conclusion\nIn this post I used Google Cloud Platform to automate the data ETL pipeline and model training. The model was then deployed in a REST API and Shiny dashboard. When considering the full MLOps cycle, the biggest missing piece is some sort of monitoring functionality. This could include data validation (e.g. trigger an alert if new data have abnormal or missing values) and model drift detection (e.g. model performance is below some threshold which triggers re-tuning). But as far as personal projects go, I’m content to leave it here and re-visit it every once in a while to see how the data and predictions are holding up.\nRegardless of the value of the model, this was a great learning experience. I’d not used GCP much before this (we use AWS at my company) but it wasn’t too painful a transition between cloud services. The packages by Mark Edmondson (googleCloudStorageR, googleCloudRunner), and the accompanying documentation, were a great help.\nDocumenting my process here was important to me. I learn best by doing, and second best by seeing what others do in open source projects like this. I hope that this walkthrough and code can help others in getting their own MLOps projects up-and-running."
  },
  {
    "objectID": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#reproducibility",
    "href": "posts/2022-05-19-predicting-bike-ridership-deploying-the-model/predicting-bike-ridership-deploying-the-model.html#reproducibility",
    "title": "Predicting bike ridership: deploying the model",
    "section": "Reproducibility",
    "text": "Reproducibility\n\n\n\nSession info\n\n\n\n setting  value\n version  R version 4.2.1 (2022-06-23 ucrt)\n os       Windows 10 x64 (build 19044)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_Canada.utf8\n ctype    English_Canada.utf8\n tz       America/Curacao\n date     2022-08-21\n pandoc   2.18 @ C:/Program Files/RStudio/bin/quarto/bin/tools/ (via rmarkdown)\n\n\n\n\n  \n\n\n\n\n\n\nGit repository\n\n\n\nLocal:    main C:/Users/tdunn/Documents/tdunn-quarto\nRemote:   main @ origin (https://github.com/taylordunn/tdunn-quarto.git)\nHead:     [49e12c6] 2022-08-21: Finishing converting `predicting-bike-ridership-developing-a-model` post\n\n\n\nSource code, R environment"
  }
]